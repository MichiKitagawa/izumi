---

## **ステップ1: 開発環境の準備**

### **1.1. 必要なソフトウェアのインストール**

1. **Gitのインストール**
    - **Windowsの場合:**
        - [Git公式サイト](https://git-scm.com/download/win)からGitをダウンロードし、インストールします。
        - インストール中のオプションはデフォルトのままで問題ありません。
2. **Node.jsのインストール**
    - **Windowsの場合:**
        - [Node.js公式サイト](https://nodejs.org/)から最新のLTS（長期サポート）バージョンをダウンロードし、インストールします。
        - インストール後、コマンドプロンプト（またはPowerShell）を開き、以下のコマンドでインストールが成功したか確認します。
            
            ```bash
            node -v
            npm -v
            
            ```
            
3. **Visual Studio Code (VSCode) のインストール**
    - [VSCode公式サイト](https://code.visualstudio.com/)からダウンロードし、インストールします。
    - **推奨拡張機能:**
        - **ESLint:** コードの品質を保つためのツール。
        - **Prettier:** コードの整形ツール。
        - **GitLens:** Git操作を支援する拡張機能。
        - **React Native Tools:** React Native開発支援。
        - **Docker:** Dockerファイルの編集支援。
4. **PostgreSQLのインストール**
    - [PostgreSQL公式サイト](https://www.postgresql.org/download/)からインストールします。
    - インストール中に設定したパスワードを控えておいてください。
5. **AWS CLIのインストール（オプション）**
    - AWSを使用する場合、[AWS CLI公式ガイド](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html)に従ってインストールします。

### **1.2. GitHubリポジトリの作成**

1. **GitHubアカウントの作成**
    - まだ持っていない場合は、[GitHub](https://github.com/)でアカウントを作成します。
2. **新しいリポジトリの作成**
    - GitHubにログインし、右上の「+」ボタンから「New repository」を選択します。
    - **リポジトリ名:** `izumi`
    - **説明:** `情報商材サブスクリプションプラットフォーム`
    - **プライバシー設定:** 公開（Public）または非公開（Private）を選択。
    - **初期設定:** READMEファイルを追加するオプションにチェックを入れて、「Create repository」をクリックします。

### **1.3. プロジェクトディレクトリの構造作成**

1. **プロジェクトフォルダの作成**
    - 任意の場所（例: `C:\Users\k0803\Projects`）に`izumi`フォルダを作成します。
        
        ```bash
        mkdir C:\Users\k0803\Projects\izumi
        cd C:\Users\k0803\Projects\izumi
        
        ```
        
2. **サブディレクトリの作成**
    - `client`（Webアプリ用）と`server`（バックエンド用）フォルダを作成します。
        
        ```bash
        mkdir client
        mkdir server
        
        ```
        

### **1.4. Gitリポジトリの初期化と設定**

1. **リポジトリの初期化**
    - プロジェクトルート（`izumi`フォルダ）でGitを初期化します。
        
        ```bash
        git init
        
        ```
        
2. **リモートリポジトリの追加**
    - 作成したGitHubリポジトリをリモートとして追加します。
        
        ```bash
        git remote add origin https://github.com/あなたのGitHubユーザー名/izumi.git
        
        ```
        
3. **初回コミットの作成**
    - `client`と`server`フォルダをGitに追加し、初回コミットを行います。
        
        ```bash
        git add .
        git commit -m "Initial commit with client and server directories"
        git push -u origin master
        
        ```
        

---

## **ステップ2: バックエンドのセットアップ**

### **2.1. Node.jsプロジェクトの初期化**

1. **サーバーディレクトリに移動**
    
    ```bash
    cd server
    
    ```
    
2. **npmプロジェクトの初期化**
    
    ```bash
    npm init -y
    
    ```
    
    - これにより、`package.json`が生成されます。

### **2.2. 必要なパッケージのインストール**

1. **Express.jsのインストール**
    
    ```bash
    npm install express
    
    ```
    
2. **開発用依存関係のインストール**
    
    ```bash
    npm install --save-dev nodemon typescript @types/express ts-node
    
    ```
    
    - **nodemon:** コード変更時に自動でサーバーを再起動。
    - **typescript:** TypeScriptのコンパイラ。
    - **@types/express:** Express.jsの型定義。
    - **ts-node:** TypeScriptファイルを直接実行。
3. **TypeScriptの初期化**
    
    ```bash
    npx tsc --init
    
    ```
    
    - `tsconfig.json`が生成されます。以下の設定を追加または変更してください。
        
        ```json
        {
          "compilerOptions": {
            "target": "ES6",
            "module": "commonjs",
            "rootDir": "./src",
            "outDir": "./dist",
            "esModuleInterop": true,
            "strict": true,
            "skipLibCheck": true
          }
        }
        
        ```
        

### **2.3. ディレクトリ構造の作成**

1. **ソースコード用フォルダの作成**
    
    ```bash
    mkdir src
    cd src
    
    ```
    
2. **基本的なファイルの作成**
    - `index.ts`: サーバーのエントリーポイント。
        
        ```tsx
        // src/index.ts
        import express from 'express';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        

### **2.4. 開発スクリプトの設定**

1. **`package.json`の修正**
    - `scripts`セクションを以下のように変更します。
        
        ```json
        "scripts": {
          "build": "tsc",
          "start": "node dist/index.js",
          "dev": "nodemon src/index.ts"
        },
        
        ```
        

### **2.5. サーバーの起動確認**

1. **開発サーバーの起動**
    
    ```bash
    npm run dev
    
    ```
    
    - ブラウザで`http://localhost:5000`にアクセスし、「Hello izumi!」と表示されれば成功です。

### **2.6. Gitへのコミット**

1. **変更のステージングとコミット**
    
    ```bash
    git add .
    git commit -m "Set up Express server with TypeScript"
    git push
    
    ```
    

---

## **ステップ3: フロントエンドのセットアップ**

### **3.1. React.jsプロジェクトの初期化**

1. **クライアントディレクトリに移動**
    
    ```bash
    cd ../client
    
    ```
    
2. **Viteを使用したReactプロジェクトの作成**
    
    ```bash
    npm create vite@latest
    
    ```
    
    - **プロジェクト名:** `client`（既にクライアントディレクトリ内にいるため、適宜選択）
    - **テンプレート選択:** `React` を選びます。
3. **依存関係のインストール**
    
    ```bash
    npm install
    
    ```
    

### **3.2. 必要なパッケージのインストール**

1. **React Routerのインストール**
    
    ```bash
    npm install react-router-dom
    
    ```
    
2. **Reduxと関連パッケージのインストール**
    
    ```bash
    npm install redux react-redux @reduxjs/toolkit
    
    ```
    
3. **Material-UIのインストール**
    
    ```bash
    npm install @mui/material @emotion/react @emotion/styled
    
    ```
    
4. **その他必要なパッケージのインストール**
    - **Axios（HTTPクライアント）**
        
        ```bash
        npm install axios
        
        ```
        
    - **その他UIコンポーネントやライブラリ**
        
        ```bash
        npm install @tanstack/react-query lucide-react react-hook-form @hookform/resolvers zod
        
        ```
        

### **3.3. プロジェクトのディレクトリ構造の整理**

1. **`src`フォルダ内に必要なサブフォルダを作成**
    
    ```bash
    mkdir src/components
    mkdir src/pages
    mkdir src/hooks
    mkdir src/utils
    
    ```
    
2. **パスエイリアスの設定**
    - **`tsconfig.json`の編集**
        
        ```json
        {
          "compilerOptions": {
            ...
            "baseUrl": "./",
            "paths": {
              "@/*": ["src/*"]
            }
          }
        }
        
        ```
        
    - **`vite.config.ts`の編集**
        
        ```tsx
        import { defineConfig } from 'vite';
        import react from '@vitejs/plugin-react';
        import path from 'path';
        
        export default defineConfig({
          plugins: [react()],
          resolve: {
            alias: {
              '@': path.resolve(__dirname, 'src'),
            },
          },
        });
        
        ```
        

### **3.4. 開発サーバーの起動確認**

1. **開発サーバーの起動**
    
    ```bash
    npm run dev
    
    ```
    
    - ブラウザで表示されたURL（通常は`http://localhost:5173/`）にアクセスし、Reactの初期画面が表示されることを確認します。

### **3.5. Gitへのコミット**

1. **変更のステージングとコミット**
    
    ```bash
    git add .
    git commit -m "Set up React frontend with Vite and initial configurations"
    git push
    
    ```
    

---

## **ステップ4: データベースの設定**

### **4.1. PostgreSQLのデータベースとユーザーの作成**

1. **PostgreSQLにログイン**
    - コマンドプロンプトまたはPowerShellで以下を実行します。
        
        ```bash
        psql -U postgres
        
        ```
        
    - インストール時に設定したパスワードを入力します。
2. **新しいデータベースの作成**
    
    ```sql
    CREATE DATABASE izumi_db;
    
    ```
    
3. **新しいユーザーの作成と権限の付与**
    
    ```sql
    CREATE USER izumi_user WITH PASSWORD 'secure_password';
    GRANT ALL PRIVILEGES ON DATABASE izumi_db TO izumi_user;
    
    ```
    
4. **PostgreSQLからのログアウト**
    
    ```sql
    \q
    
    ```
    

### **4.2. サーバーでのデータベース接続設定**

1. **必要なパッケージのインストール**
    
    ```bash
    npm install pg sequelize
    npm install --save-dev @types/pg
    
    ```
    
    - **pg:** PostgreSQLクライアント
    - **sequelize:** ORM（Object-Relational Mapping）ツール
2. **Sequelizeの初期化**
    - **設定ファイルの作成**
        
        ```bash
        mkdir src/config
        touch src/config/database.ts
        
        ```
        
    - **`database.ts`の内容**
        
        ```tsx
        // src/config/database.ts
        import { Sequelize } from 'sequelize';
        
        const sequelize = new Sequelize('izumi_db', 'izumi_user', 'secure_password', {
          host: 'localhost',
          dialect: 'postgres',
        });
        
        export default sequelize;
        
        ```
        
3. **データベース接続のテスト**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import sequelize from './config/database';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        
    - **サーバーの再起動**
        
        ```bash
        npm run dev
        
        ```
        
    - **確認**
        - コンソールに「Database connected...」と表示されれば成功です。
4. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Set up PostgreSQL database connection with Sequelize"
    git push
    
    ```
    

---

## **ステップ5: ユーザー管理機能の実装**

### **5.1. ユーザーモデルの作成**

1. **モデルディレクトリの作成**
    
    ```bash
    mkdir src/models
    
    ```
    
2. **Userモデルの作成**
    - **`User.ts`の作成**
        
        ```tsx
        // src/models/User.ts
        import { DataTypes, Model } from 'sequelize';
        import sequelize from '../config/database';
        
        class User extends Model {
          public id!: number;
          public email!: string;
          public password!: string;
          public name!: string;
          public profileImage!: string;
          public role!: string; // 'subscriber', 'provider', 'admin'
          public readonly createdAt!: Date;
          public readonly updatedAt!: Date;
        }
        
        User.init(
          {
            id: {
              type: DataTypes.INTEGER,
              autoIncrement: true,
              primaryKey: true,
            },
            email: {
              type: DataTypes.STRING,
              allowNull: false,
              unique: true,
            },
            password: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            name: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            profileImage: {
              type: DataTypes.STRING,
              allowNull: true,
            },
            role: {
              type: DataTypes.STRING,
              allowNull: false,
              defaultValue: 'subscriber',
            },
          },
          {
            sequelize,
            tableName: 'users',
          }
        );
        
        export default User;
        
        ```
        
3. **データベースにモデルを同期**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import sequelize from './config/database';
        import User from './models/User';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.use(express.json());
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        
4. **サーバーの再起動と確認**
    
    ```bash
    npm run dev
    
    ```
    
    - コンソールに「Models synchronized.」と表示されれば成功です。
5. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Create User model and synchronize with database"
    git push
    
    ```
    

### **5.2. ユーザー登録・ログインAPIの実装**

1. **必要なパッケージのインストール**
    
    ```bash
    npm install bcrypt jsonwebtoken
    npm install --save-dev @types/bcrypt @types/jsonwebtoken
    
    ```
    
    - **bcrypt:** パスワードのハッシュ化。
    - **jsonwebtoken:** JWT認証用。
2. **認証ルートの作成**
    - **ルートディレクトリの作成**
        
        ```bash
        mkdir src/routes
        
        ```
        
    - **`auth.ts`の作成**
        
        ```tsx
        // src/routes/auth.ts
        import { Router, Request, Response } from 'express';
        import bcrypt from 'bcrypt';
        import jwt from 'jsonwebtoken';
        import User from '../models/User';
        
        const router = Router();
        
        // ユーザー登録
        router.post('/register', async (req: Request, res: Response) => {
          const { email, password, name } = req.body;
        
          try {
            // 既存ユーザーの確認
            const existingUser = await User.findOne({ where: { email } });
            if (existingUser) {
              return res.status(400).json({ message: 'Email already in use.' });
            }
        
            // パスワードのハッシュ化
            const hashedPassword = await bcrypt.hash(password, 10);
        
            // ユーザーの作成
            const user = await User.create({
              email,
              password: hashedPassword,
              name,
            });
        
            res.status(201).json({ message: 'User registered successfully.' });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        // ユーザーログイン
        router.post('/login', async (req: Request, res: Response) => {
          const { email, password } = req.body;
        
          try {
            const user = await User.findOne({ where: { email } });
            if (!user) {
              return res.status(400).json({ message: 'Invalid credentials.' });
            }
        
            // パスワードの比較
            const isMatch = await bcrypt.compare(password, user.password);
            if (!isMatch) {
              return res.status(400).json({ message: 'Invalid credentials.' });
            }
        
            // JWTの生成
            const token = jwt.sign(
              { id: user.id, email: user.email, role: user.role },
              'your_jwt_secret', // 環境変数に置き換えることを推奨
              { expiresIn: '1h' }
            );
        
            res.status(200).json({ token });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        export default router;
        
        ```
        
3. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import sequelize from './config/database';
        import User from './models/User';
        import authRoutes from './routes/auth';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.use(express.json());
        
        app.use('/api/auth', authRoutes);
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        
4. **サーバーの再起動とAPIのテスト**
    - **サーバーの起動**
        
        ```bash
        npm run dev
        
        ```
        
    - **APIのテスト**
        - [Postman](https://www.postman.com/)などのツールを使用して、以下のエンドポイントをテストします。
            - **登録:**
                - **URL:** `http://localhost:5000/api/auth/register`
                - **メソッド:** POST
                - **ボディ:** JSON
                    
                    ```json
                    {
                      "email": "user@example.com",
                      "password": "password123",
                      "name": "John Doe"
                    }
                    
                    ```
                    
            - **ログイン:**
                - **URL:** `http://localhost:5000/api/auth/login`
                - **メソッド:** POST
                - **ボディ:** JSON
                    
                    ```json
                    {
                      "email": "user@example.com",
                      "password": "password123"
                    }
                    
                    ```
                    
        - **期待されるレスポンス:**
            - 登録成功時: `201 Created` とメッセージ。
            - ログイン成功時: `200 OK` とJWTトークン。
5. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement user registration and login APIs with JWT authentication"
    git push
    
    ```
    

---

## **ステップ6: フロントエンドでのユーザー登録・ログイン機能の実装**

### **6.1. React Routerの設定**

1. **ルーティングの設定**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import React from 'react';
        import ReactDOM from 'react-dom';
        import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
        import App from './App';
        import Register from './pages/Register';
        import Login from './pages/Login';
        
        ReactDOM.render(
          <React.StrictMode>
            <Router>
              <Routes>
                <Route path="/" element={<App />} />
                <Route path="/register" element={<Register />} />
                <Route path="/login" element={<Login />} />
              </Routes>
            </Router>
          </React.StrictMode>,
          document.getElementById('root')
        );
        
        ```
        

### **6.2. ページコンポーネントの作成**

1. **`Register.tsx`の作成**
    
    ```tsx
    // src/pages/Register.tsx
    import React, { useState } from 'react';
    import axios from 'axios';
    import { TextField, Button, Container, Typography } from '@mui/material';
    
    const Register: React.FC = () => {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [name, setName] = useState('');
      const [message, setMessage] = useState('');
    
      const handleRegister = async (e: React.FormEvent) => {
        e.preventDefault();
        try {
          const res = await axios.post('/api/auth/register', { email, password, name });
          setMessage(res.data.message);
        } catch (error: any) {
          setMessage(error.response?.data?.message || 'Registration failed.');
        }
      };
    
      return (
        <Container maxWidth="sm">
          <Typography variant="h4" gutterBottom>
            Register
          </Typography>
          <form onSubmit={handleRegister}>
            <TextField
              label="Name"
              variant="outlined"
              fullWidth
              margin="normal"
              value={name}
              onChange={(e) => setName(e.target.value)}
              required
            />
            <TextField
              label="Email"
              type="email"
              variant="outlined"
              fullWidth
              margin="normal"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
            <TextField
              label="Password"
              type="password"
              variant="outlined"
              fullWidth
              margin="normal"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            <Button type="submit" variant="contained" color="primary" fullWidth>
              Register
            </Button>
          </form>
          {message && <Typography variant="body1">{message}</Typography>}
        </Container>
      );
    };
    
    export default Register;
    
    ```
    
2. **`Login.tsx`の作成**
    
    ```tsx
    // src/pages/Login.tsx
    import React, { useState } from 'react';
    import axios from 'axios';
    import { TextField, Button, Container, Typography } from '@mui/material';
    
    const Login: React.FC = () => {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [message, setMessage] = useState('');
    
      const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        try {
          const res = await axios.post('/api/auth/login', { email, password });
          localStorage.setItem('token', res.data.token);
          setMessage('Login successful!');
        } catch (error: any) {
          setMessage(error.response?.data?.message || 'Login failed.');
        }
      };
    
      return (
        <Container maxWidth="sm">
          <Typography variant="h4" gutterBottom>
            Login
          </Typography>
          <form onSubmit={handleLogin}>
            <TextField
              label="Email"
              type="email"
              variant="outlined"
              fullWidth
              margin="normal"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
            <TextField
              label="Password"
              type="password"
              variant="outlined"
              fullWidth
              margin="normal"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            <Button type="submit" variant="contained" color="primary" fullWidth>
              Login
            </Button>
          </form>
          {message && <Typography variant="body1">{message}</Typography>}
        </Container>
      );
    };
    
    export default Login;
    
    ```
    
3. **`App.tsx`の編集**
    - 必要に応じてナビゲーションバーや他のページへのリンクを追加します。
    
    ```tsx
    // src/App.tsx
    import React from 'react';
    import { Link } from 'react-router-dom';
    import { AppBar, Toolbar, Typography, Button } from '@mui/material';
    
    const App: React.FC = () => {
      return (
        <div>
          <AppBar position="static">
            <Toolbar>
              <Typography variant="h6" style={{ flexGrow: 1 }}>
                izumi
              </Typography>
              <Button color="inherit" component={Link} to="/register">
                Register
              </Button>
              <Button color="inherit" component={Link} to="/login">
                Login
              </Button>
            </Toolbar>
          </AppBar>
          <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
            Welcome to izumi
          </Typography>
        </div>
      );
    };
    
    export default App;
    
    ```
    

### **6.3. プロキシ設定の追加**

1. **`vite.config.ts`の編集**
    - フロントエンドからバックエンドへのAPIリクエストをプロキシする設定を追加します。
        
        ```tsx
        // vite.config.ts
        import { defineConfig } from 'vite';
        import react from '@vitejs/plugin-react';
        import path from 'path';
        
        export default defineConfig({
          plugins: [react()],
          resolve: {
            alias: {
              '@': path.resolve(__dirname, 'src'),
            },
          },
          server: {
            proxy: {
              '/api': {
                target: 'http://localhost:5000',
                changeOrigin: true,
                secure: false,
              },
            },
          },
        });
        
        ```
        

### **6.4. サーバーのCORS設定**

1. **CORSパッケージのインストール**
    
    ```bash
    npm install cors
    npm install --save-dev @types/cors
    
    ```
    
2. **`index.ts`の修正**
    
    ```tsx
    // src/index.ts
    import express from 'express';
    import sequelize from './config/database';
    import User from './models/User';
    import authRoutes from './routes/auth';
    import cors from 'cors';
    
    const app = express();
    const PORT = process.env.PORT || 5000;
    
    app.use(cors());
    app.use(express.json());
    
    app.use('/api/auth', authRoutes);
    
    app.get('/', (req, res) => {
      res.send('Hello izumi!');
    });
    
    sequelize.authenticate()
      .then(() => {
        console.log('Database connected...');
        return sequelize.sync();
      })
      .then(() => {
        console.log('Models synchronized.');
      })
      .catch((err) => {
        console.error('Unable to connect to the database:', err);
      });
    
    app.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}`);
    });
    
    ```
    
3. **サーバーとフロントエンドの再起動**
    - **サーバー:**
        
        ```bash
        npm run dev
        
        ```
        
    - **クライアント:**
        
        ```bash
        cd ../client
        npm run dev
        
        ```
        

### **6.5. フロントエンドからのAPIリクエストのテスト**

1. **ブラウザで`http://localhost:5173/register`にアクセスし、ユーザー登録フォームに必要事項を入力して送信します。**
    - 登録が成功すると、「User registered successfully.」というメッセージが表示されます。
2. **同様に、`http://localhost:5173/login`にアクセスし、登録したユーザーでログインします。**
    - ログインが成功すると、「Login successful!」というメッセージが表示され、JWTトークンがローカルストレージに保存されます。

### **6.6. Gitへのコミット**

1. **変更のステージングとコミット**
    
    ```bash
    git add .
    git commit -m "Implement frontend user registration and login pages with API integration"
    git push
    
    ```
    

---

## **ステップ7: ユーザープロフィール編集機能の実装**

### **7.1. バックエンドでのプロフィール編集APIの実装**

1. **`User`モデルの拡張**
    - 既に`name`と`profileImage`フィールドが存在しますが、必要に応じて追加フィールドを追加します。
2. **プロフィール編集ルートの作成**
    - **`profile.ts`の作成**
        
        ```tsx
        // src/routes/profile.ts
        import { Router, Request, Response } from 'express';
        import jwt from 'jsonwebtoken';
        import User from '../models/User';
        
        const router = Router();
        
        // ミドルウェア: JWT認証
        const authenticateToken = (req: Request, res: Response, next: Function) => {
          const authHeader = req.headers['authorization'];
          const token = authHeader && authHeader.split(' ')[1];
        
          if (!token) return res.sendStatus(401);
        
          jwt.verify(token, 'your_jwt_secret', (err: any, user: any) => {
            if (err) return res.sendStatus(403);
            req.body.user = user;
            next();
          });
        };
        
        // プロフィール取得
        router.get('/', authenticateToken, async (req: Request, res: Response) => {
          const userId = req.body.user.id;
          try {
            const user = await User.findByPk(userId, {
              attributes: ['id', 'email', 'name', 'profileImage', 'role'],
            });
            if (!user) {
              return res.status(404).json({ message: 'User not found.' });
            }
            res.status(200).json(user);
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        // プロフィール編集
        router.put('/', authenticateToken, async (req: Request, res: Response) => {
          const userId = req.body.user.id;
          const { name, profileImage } = req.body;
        
          try {
            const user = await User.findByPk(userId);
            if (!user) {
              return res.status(404).json({ message: 'User not found.' });
            }
        
            user.name = name || user.name;
            user.profileImage = profileImage || user.profileImage;
        
            await user.save();
        
            res.status(200).json({ message: 'Profile updated successfully.' });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        export default router;
        
        ```
        
3. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import sequelize from './config/database';
        import User from './models/User';
        import authRoutes from './routes/auth';
        import profileRoutes from './routes/profile';
        import cors from 'cors';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.use(cors());
        app.use(express.json());
        
        app.use('/api/auth', authRoutes);
        app.use('/api/profile', profileRoutes);
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        
4. **サーバーの再起動とAPIのテスト**
    
    ```bash
    npm run dev
    
    ```
    
    - **プロフィール取得:**
        - **URL:** `http://localhost:5000/api/profile/`
        - **メソッド:** GET
        - **ヘッダー:** `Authorization: Bearer <JWTトークン>`
    - **プロフィール編集:**
        - **URL:** `http://localhost:5000/api/profile/`
        - **メソッド:** PUT
        - **ヘッダー:** `Authorization: Bearer <JWTトークン>`
        - **ボディ:** JSON
            
            ```json
            {
              "name": "Jane Doe",
              "profileImage": "https://example.com/image.jpg"
            }
            
            ```
            

### **7.2. フロントエンドでのプロフィール編集ページの作成**

1. **`Profile.tsx`の作成**
    
    ```tsx
    // src/pages/Profile.tsx
    import React, { useState, useEffect } from 'react';
    import axios from 'axios';
    import { TextField, Button, Container, Typography } from '@mui/material';
    
    const Profile: React.FC = () => {
      const [name, setName] = useState('');
      const [profileImage, setProfileImage] = useState('');
      const [message, setMessage] = useState('');
    
      useEffect(() => {
        const fetchProfile = async () => {
          const token = localStorage.getItem('token');
          try {
            const res = await axios.get('/api/profile/', {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });
            setName(res.data.name);
            setProfileImage(res.data.profileImage);
          } catch (error: any) {
            setMessage(error.response?.data?.message || 'Failed to fetch profile.');
          }
        };
    
        fetchProfile();
      }, []);
    
      const handleUpdate = async (e: React.FormEvent) => {
        e.preventDefault();
        const token = localStorage.getItem('token');
        try {
          const res = await axios.put(
            '/api/profile/',
            { name, profileImage },
            {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            }
          );
          setMessage(res.data.message);
        } catch (error: any) {
          setMessage(error.response?.data?.message || 'Update failed.');
        }
      };
    
      return (
        <Container maxWidth="sm">
          <Typography variant="h4" gutterBottom>
            Profile
          </Typography>
          <form onSubmit={handleUpdate}>
            <TextField
              label="Name"
              variant="outlined"
              fullWidth
              margin="normal"
              value={name}
              onChange={(e) => setName(e.target.value)}
              required
            />
            <TextField
              label="Profile Image URL"
              variant="outlined"
              fullWidth
              margin="normal"
              value={profileImage}
              onChange={(e) => setProfileImage(e.target.value)}
            />
            <Button type="submit" variant="contained" color="primary" fullWidth>
              Update Profile
            </Button>
          </form>
          {message && <Typography variant="body1">{message}</Typography>}
        </Container>
      );
    };
    
    export default Profile;
    
    ```
    
2. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import React from 'react';
        import ReactDOM from 'react-dom';
        import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
        import App from './App';
        import Register from './pages/Register';
        import Login from './pages/Login';
        import Profile from './pages/Profile';
        
        ReactDOM.render(
          <React.StrictMode>
            <Router>
              <Routes>
                <Route path="/" element={<App />} />
                <Route path="/register" element={<Register />} />
                <Route path="/login" element={<Login />} />
                <Route path="/profile" element={<Profile />} />
              </Routes>
            </Router>
          </React.StrictMode>,
          document.getElementById('root')
        );
        
        ```
        
3. **ナビゲーションの更新**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        
        const App: React.FC = () => {
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  <Button color="inherit" component={Link} to="/register">
                    Register
                  </Button>
                  <Button color="inherit" component={Link} to="/login">
                    Login
                  </Button>
                  <Button color="inherit" component={Link} to="/profile">
                    Profile
                  </Button>
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                Welcome to izumi
              </Typography>
            </div>
          );
        };
        
        export default App;
        
        ```
        
4. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement profile page with fetch and update functionality"
    git push
    
    ```
    

---

## **ステップ8: 提供者と購読者のロール管理の実装**

### **8.1. ロールに応じたアクセス制御の実装**

1. **バックエンドでのミドルウェア作成**
    - **`authMiddleware.ts`の作成**
        
        ```tsx
        // src/middleware/authMiddleware.ts
        import { Request, Response, NextFunction } from 'express';
        import jwt from 'jsonwebtoken';
        
        interface AuthenticatedRequest extends Request {
          user?: any;
        }
        
        export const authenticateToken = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
          const authHeader = req.headers['authorization'];
          const token = authHeader && authHeader.split(' ')[1];
        
          if (!token) return res.sendStatus(401);
        
          jwt.verify(token, 'your_jwt_secret', (err: any, user: any) => {
            if (err) return res.sendStatus(403);
            req.user = user;
            next();
          });
        };
        
        export const authorizeRoles = (...roles: string[]) => {
          return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
            if (!req.user || !roles.includes(req.user.role)) {
              return res.sendStatus(403);
            }
            next();
          };
        };
        
        ```
        
2. **ルートでのミドルウェア適用**
    - 例として、管理者専用のルートを作成します。
    - **`admin.ts`の作成**
        
        ```tsx
        // src/routes/admin.ts
        import { Router, Request, Response } from 'express';
        import { authenticateToken, authorizeRoles } from '../middleware/authMiddleware';
        import User from '../models/User';
        
        const router = Router();
        
        // ユーザー一覧の取得（管理者専用）
        router.get('/users', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
          try {
            const users = await User.findAll({
              attributes: ['id', 'email', 'name', 'role', 'createdAt', 'updatedAt'],
            });
            res.status(200).json(users);
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        // ユーザーのBAN
        router.post('/ban/:id', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
          const userId = req.params.id;
          try {
            const user = await User.findByPk(userId);
            if (!user) {
              return res.status(404).json({ message: 'User not found.' });
            }
            // ここでユーザーをBANするためのロジックを実装
            // 例: user.banned = true;
            // await user.save();
            res.status(200).json({ message: 'User banned successfully.' });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        export default router;
        
        ```
        
3. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import sequelize from './config/database';
        import User from './models/User';
        import authRoutes from './routes/auth';
        import profileRoutes from './routes/profile';
        import adminRoutes from './routes/admin';
        import cors from 'cors';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.use(cors());
        app.use(express.json());
        
        app.use('/api/auth', authRoutes);
        app.use('/api/profile', profileRoutes);
        app.use('/api/admin', adminRoutes);
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        
4. **フロントエンドでの管理者ページの作成**
    - **`Admin.tsx`の作成**
        
        ```tsx
        // src/pages/Admin.tsx
        import React, { useState, useEffect } from 'react';
        import axios from 'axios';
        import { Container, Typography, Table, TableBody, TableCell, TableHead, TableRow, Button } from '@mui/material';
        
        const Admin: React.FC = () => {
          const [users, setUsers] = useState([]);
          const [message, setMessage] = useState('');
        
          useEffect(() => {
            const fetchUsers = async () => {
              const token = localStorage.getItem('token');
              try {
                const res = await axios.get('/api/admin/users', {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                });
                setUsers(res.data);
              } catch (error: any) {
                setMessage(error.response?.data?.message || 'Failed to fetch users.');
              }
            };
        
            fetchUsers();
          }, []);
        
          const handleBan = async (id: number) => {
            const token = localStorage.getItem('token');
            try {
              const res = await axios.post(`/api/admin/ban/${id}`, {}, {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
              });
              setMessage(res.data.message);
              // 更新後のユーザーリストを再取得
              const updatedUsers = users.map((user: any) =>
                user.id === id ? { ...user, banned: true } : user
              );
              setUsers(updatedUsers);
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Failed to ban user.');
            }
          };
        
          return (
            <Container>
              <Typography variant="h4" gutterBottom>
                Admin Panel
              </Typography>
              {message && <Typography variant="body1">{message}</Typography>}
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>ID</TableCell>
                    <TableCell>Email</TableCell>
                    <TableCell>Name</TableCell>
                    <TableCell>Role</TableCell>
                    <TableCell>Actions</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {users.map((user: any) => (
                    <TableRow key={user.id}>
                      <TableCell>{user.id}</TableCell>
                      <TableCell>{user.email}</TableCell>
                      <TableCell>{user.name}</TableCell>
                      <TableCell>{user.role}</TableCell>
                      <TableCell>
                        <Button variant="contained" color="secondary" onClick={() => handleBan(user.id)}>
                          BAN
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Container>
          );
        };
        
        export default Admin;
        
        ```
        
5. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import React from 'react';
        import ReactDOM from 'react-dom';
        import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
        import App from './App';
        import Register from './pages/Register';
        import Login from './pages/Login';
        import Profile from './pages/Profile';
        import Admin from './pages/Admin';
        
        ReactDOM.render(
          <React.StrictMode>
            <Router>
              <Routes>
                <Route path="/" element={<App />} />
                <Route path="/register" element={<Register />} />
                <Route path="/login" element={<Login />} />
                <Route path="/profile" element={<Profile />} />
                <Route path="/admin" element={<Admin />} />
              </Routes>
            </Router>
          </React.StrictMode>,
          document.getElementById('root')
        );
        
        ```
        
6. **管理者ページへのアクセス制御**
    - **ユーザーのロールを確認して表示制限を行う**
        - **`App.tsx`の修正**
            
            ```tsx
            // src/App.tsx
            import React from 'react';
            import { Link } from 'react-router-dom';
            import { AppBar, Toolbar, Typography, Button } from '@mui/material';
            
            const App: React.FC = () => {
              const token = localStorage.getItem('token');
              const [role, setRole] = React.useState<string | null>(null);
            
              React.useEffect(() => {
                if (token) {
                  const decoded: any = JSON.parse(atob(token.split('.')[1]));
                  setRole(decoded.role);
                }
              }, [token]);
            
              return (
                <div>
                  <AppBar position="static">
                    <Toolbar>
                      <Typography variant="h6" style={{ flexGrow: 1 }}>
                        izumi
                      </Typography>
                      {!token && (
                        <>
                          <Button color="inherit" component={Link} to="/register">
                            Register
                          </Button>
                          <Button color="inherit" component={Link} to="/login">
                            Login
                          </Button>
                        </>
                      )}
                      {token && (
                        <>
                          <Button color="inherit" component={Link} to="/profile">
                            Profile
                          </Button>
                          {role === 'admin' && (
                            <Button color="inherit" component={Link} to="/admin">
                              Admin
                            </Button>
                          )}
                        </>
                      )}
                    </Toolbar>
                  </AppBar>
                  <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                    Welcome to izumi
                  </Typography>
                </div>
              );
            };
            
            export default App;
            
            ```
            
7. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement admin panel with user management and role-based access control"
    git push
    
    ```
    

---

## **ステップ9: 商材管理機能の実装**

### **9.1. 商材モデルの作成**

1. **`Product.ts`の作成**
    
    ```tsx
    // src/models/Product.ts
    import { DataTypes, Model } from 'sequelize';
    import sequelize from '../config/database';
    import User from './User';
    
    class Product extends Model {
      public id!: number;
      public title!: string;
      public description!: string;
      public category!: string;
      public fileUrl!: string;
      public fileType!: string; // PDF, MP4, MP3
      public fileSize!: number; // in bytes
      public providerId!: number;
      public readonly createdAt!: Date;
      public readonly updatedAt!: Date;
    }
    
    Product.init(
      {
        id: {
          type: DataTypes.INTEGER,
          autoIncrement: true,
          primaryKey: true,
        },
        title: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        description: {
          type: DataTypes.TEXT,
          allowNull: false,
        },
        category: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        fileUrl: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        fileType: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        fileSize: {
          type: DataTypes.INTEGER,
          allowNull: false,
        },
        providerId: {
          type: DataTypes.INTEGER,
          allowNull: false,
          references: {
            model: User,
            key: 'id',
          },
        },
      },
      {
        sequelize,
        tableName: 'products',
      }
    );
    
    export default Product;
    
    ```
    
2. **モデルの関連付け**
    - **`User.ts`の編集**
        
        ```tsx
        // src/models/User.ts
        import { DataTypes, Model, HasManyGetAssociationsMixin } from 'sequelize';
        import sequelize from '../config/database';
        import Product from './Product';
        
        class User extends Model {
          public id!: number;
          public email!: string;
          public password!: string;
          public name!: string;
          public profileImage!: string;
          public role!: string; // 'subscriber', 'provider', 'admin'
          public readonly createdAt!: Date;
          public readonly updatedAt!: Date;
        
          // Association methods
          public getProducts!: HasManyGetAssociationsMixin<Product>;
        }
        
        User.init(
          {
            id: {
              type: DataTypes.INTEGER,
              autoIncrement: true,
              primaryKey: true,
            },
            email: {
              type: DataTypes.STRING,
              allowNull: false,
              unique: true,
            },
            password: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            name: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            profileImage: {
              type: DataTypes.STRING,
              allowNull: true,
            },
            role: {
              type: DataTypes.STRING,
              allowNull: false,
              defaultValue: 'subscriber',
            },
          },
          {
            sequelize,
            tableName: 'users',
          }
        );
        
        User.hasMany(Product, { foreignKey: 'providerId', as: 'products' });
        Product.belongsTo(User, { foreignKey: 'providerId', as: 'provider' });
        
        export default User;
        
        ```
        
3. **データベースの同期**
    - **サーバーの再起動**
        
        ```bash
        npm run dev
        
        ```
        
    - コンソールに「Models synchronized.」と表示され、新しいテーブルが作成されます。
4. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Create Product model and associate with User"
    git push
    
    ```
    

### **9.2. 商材アップロードAPIの実装**

1. **ファイルアップロード用のパッケージのインストール**
    
    ```bash
    npm install multer
    npm install --save-dev @types/multer
    
    ```
    
    - **multer:** ファイルアップロードを処理するミドルウェア。
2. **AWS SDKのインストール**
    
    ```bash
    npm install aws-sdk
    npm install --save-dev @types/aws-sdk
    
    ```
    
    - **aws-sdk:** AWS S3にファイルをアップロードするためのライブラリ。
3. **AWS S3の設定**
    - **AWSアカウントの作成（まだの場合）**
        - [AWS公式サイト](https://aws.amazon.com/)からアカウントを作成します。
    - **S3バケットの作成**
        - AWS管理コンソールからS3サービスにアクセスし、新しいバケットを作成します。
        - バケット名やリージョンを設定し、公開アクセスを制限します。
    - **アクセスキーの取得**
        - IAMサービスから新しいユーザーを作成し、S3へのアクセス権限を付与します。
        - アクセスキーIDとシークレットアクセスキーを安全な場所に保存します。
4. **ファイルアップロードルートの作成**
    - **`product.ts`の作成**
        
        ```tsx
        // src/routes/product.ts
        import { Router, Request, Response } from 'express';
        import multer from 'multer';
        import AWS from 'aws-sdk';
        import { authenticateToken, authorizeRoles } from '../middleware/authMiddleware';
        import Product from '../models/Product';
        
        const router = Router();
        
        // AWS S3設定
        const s3 = new AWS.S3({
          accessKeyId: 'YOUR_AWS_ACCESS_KEY_ID',
          secretAccessKey: 'YOUR_AWS_SECRET_ACCESS_KEY',
          region: 'YOUR_S3_BUCKET_REGION',
        });
        
        // multer設定
        const storage = multer.memoryStorage();
        const upload = multer({
          storage,
          limits: { fileSize: 100 * 1024 * 1024 }, // 100MB
          fileFilter: (req, file, cb) => {
            const allowedTypes = ['application/pdf', 'video/mp4', 'audio/mpeg'];
            if (allowedTypes.includes(file.mimetype)) {
              cb(null, true);
            } else {
              cb(new Error('Invalid file type.'));
            }
          },
        });
        
        // 商材アップロード
        router.post(
          '/upload',
          authenticateToken,
          authorizeRoles('provider'),
          upload.single('file'),
          async (req: Request, res: Response) => {
            const { title, description, category } = req.body;
            const file = req.file;
        
            if (!file) {
              return res.status(400).json({ message: 'No file uploaded.' });
            }
        
            // S3にファイルをアップロード
            const params = {
              Bucket: 'YOUR_S3_BUCKET_NAME',
              Key: `${Date.now()}_${file.originalname}`,
              Body: file.buffer,
              ContentType: file.mimetype,
            };
        
            try {
              const data = await s3.upload(params).promise();
              // 商材情報のデータベース保存
              const product = await Product.create({
                title,
                description,
                category,
                fileUrl: data.Location,
                fileType: file.mimetype.split('/')[1], // 'pdf', 'mp4', 'mp3'
                fileSize: file.size,
                providerId: req.user.id,
              });
        
              res.status(201).json({ message: 'Product uploaded successfully.', product });
            } catch (error) {
              console.error(error);
              res.status(500).json({ message: 'File upload failed.' });
            }
          }
        );
        
        export default router;
        
        ```
        
5. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import sequelize from './config/database';
        import User from './models/User';
        import Product from './models/Product';
        import authRoutes from './routes/auth';
        import profileRoutes from './routes/profile';
        import adminRoutes from './routes/admin';
        import productRoutes from './routes/product';
        import cors from 'cors';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.use(cors());
        app.use(express.json());
        
        app.use('/api/auth', authRoutes);
        app.use('/api/profile', profileRoutes);
        app.use('/api/admin', adminRoutes);
        app.use('/api/product', productRoutes);
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        
6. **フロントエンドでの商材アップロードページの作成**
    - **`UploadProduct.tsx`の作成**
        
        ```tsx
        // src/pages/UploadProduct.tsx
        import React, { useState } from 'react';
        import axios from 'axios';
        import { TextField, Button, Container, Typography, Select, MenuItem, InputLabel, FormControl } from '@mui/material';
        
        const UploadProduct: React.FC = () => {
          const [title, setTitle] = useState('');
          const [description, setDescription] = useState('');
          const [category, setCategory] = useState('');
          const [file, setFile] = useState<File | null>(null);
          const [message, setMessage] = useState('');
        
          const handleUpload = async (e: React.FormEvent) => {
            e.preventDefault();
            if (!file) {
              setMessage('Please select a file to upload.');
              return;
            }
        
            const token = localStorage.getItem('token');
            const formData = new FormData();
            formData.append('title', title);
            formData.append('description', description);
            formData.append('category', category);
            formData.append('file', file);
        
            try {
              const res = await axios.post('/api/product/upload', formData, {
                headers: {
                  'Content-Type': 'multipart/form-data',
                  Authorization: `Bearer ${token}`,
                },
              });
              setMessage(res.data.message);
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Upload failed.');
            }
          };
        
          return (
            <Container maxWidth="sm">
              <Typography variant="h4" gutterBottom>
                Upload Product
              </Typography>
              <form onSubmit={handleUpload}>
                <TextField
                  label="Title"
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  required
                />
                <TextField
                  label="Description"
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  multiline
                  rows={4}
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  required
                />
                <FormControl fullWidth margin="normal">
                  <InputLabel>Category</InputLabel>
                  <Select value={category} onChange={(e) => setCategory(e.target.value as string)} required>
                    <MenuItem value="Education">Education</MenuItem>
                    <MenuItem value="Business">Business</MenuItem>
                    <MenuItem value="Lifestyle">Lifestyle</MenuItem>
                    {/* 必要に応じてカテゴリーを追加 */}
                  </Select>
                </FormControl>
                <Button variant="contained" component="label" fullWidth style={{ marginTop: '20px' }}>
                  Select File
                  <input
                    type="file"
                    hidden
                    onChange={(e) => {
                      if (e.target.files && e.target.files[0]) {
                        setFile(e.target.files[0]);
                      }
                    }}
                  />
                </Button>
                {file && <Typography variant="body1" style={{ marginTop: '10px' }}>{file.name}</Typography>}
                <Button type="submit" variant="contained" color="primary" fullWidth style={{ marginTop: '20px' }}>
                  Upload
                </Button>
              </form>
              {message && <Typography variant="body1">{message}</Typography>}
            </Container>
          );
        };
        
        export default UploadProduct;
        
        ```
        
7. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import React from 'react';
        import ReactDOM from 'react-dom';
        import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
        import App from './App';
        import Register from './pages/Register';
        import Login from './pages/Login';
        import Profile from './pages/Profile';
        import Admin from './pages/Admin';
        import UploadProduct from './pages/UploadProduct';
        
        ReactDOM.render(
          <React.StrictMode>
            <Router>
              <Routes>
                <Route path="/" element={<App />} />
                <Route path="/register" element={<Register />} />
                <Route path="/login" element={<Login />} />
                <Route path="/profile" element={<Profile />} />
                <Route path="/admin" element={<Admin />} />
                <Route path="/upload" element={<UploadProduct />} />
              </Routes>
            </Router>
          </React.StrictMode>,
          document.getElementById('root')
        );
        
        ```
        
8. **ナビゲーションの更新**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        
        const App: React.FC = () => {
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        Register
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        Login
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        Profile
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          Admin
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          Upload Product
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                Welcome to izumi
              </Typography>
            </div>
          );
        };
        
        export default App;
        
        ```
        
9. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement product upload functionality with AWS S3 integration"
    git push
    
    ```
    

---

## **ステップ10: 継続的な機能実装とテスト**

### **10.1. その他の機能の実装**

- **評価機能、ダウンロード機能、マイリスト機能などの実装**
    - 各機能ごとにモデルの作成、APIの実装、フロントエンドのページ・コンポーネントの作成を行います。
    - 各機能の詳細は要件定義書に基づき、上記のステップに沿って進めてください。

### **10.2. テストの実装**

1. **バックエンドテストの設定**
    - **必要なパッケージのインストール**
        
        ```bash
        npm install --save-dev mocha chai supertest
        
        ```
        
    - **テストスクリプトの追加**
        - **`package.json`の編集**
            
            ```json
            "scripts": {
              ...
              "test": "mocha -r ts-node/register tests/**/*.test.ts"
            },
            
            ```
            
2. **フロントエンドテストの設定**
    - **必要なパッケージのインストール**
        
        ```bash
        npm install --save-dev jest @testing-library/react @testing-library/jest-dom
        
        ```
        
    - **Jestの設定**
        - **`jest.config.js`の作成**
            
            ```jsx
            module.exports = {
              testEnvironment: 'jsdom',
              setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
              transform: {
                '^.+\\.tsx?$': 'ts-jest',
              },
              moduleNameMapper: {
                '^@/(.*)$': '<rootDir>/src/$1',
              },
            };
            
            ```
            
        - **`setupTests.ts`の作成**
            
            ```tsx
            import '@testing-library/jest-dom';
            
            ```
            
3. **テストの作成と実行**
    - 各機能に対してユニットテストや統合テストを作成し、`npm run test`で実行します。

### **10.3. Gitへのコミットとプッシュ**

```bash
git add .
git commit -m "Implement testing framework and add initial tests"
git push

```

---

## **ステップ11: 継続的インテグレーションとデプロイの設定**

### **11.1. GitHub Actionsの設定**

1. **GitHubリポジトリでの設定**
    - GitHubリポジトリにアクセスし、「Actions」タブをクリックします。
    - 「Set up a workflow yourself」を選択し、以下の内容で`.github/workflows/ci.yml`を作成します。
2. **CIワークフローの作成**
    
    ```yaml
    name: CI
    
    on:
      push:
        branches: [ master ]
      pull_request:
        branches: [ master ]
    
    jobs:
      build:
    
        runs-on: ubuntu-latest
    
        strategy:
          matrix:
            node-version: [14.x, 16.x]
    
        steps:
        - uses: actions/checkout@v2
        - name: Use Node.js ${{ matrix.node-version }}
          uses: actions/setup-node@v2
          with:
            node-version: ${{ matrix.node-version }}
        - run: cd server && npm install
        - run: cd server && npm run build
        - run: cd server && npm test
        - run: cd client && npm install
        - run: cd client && npm run build
        - run: cd client && npm test
    
    ```
    
3. **GitHub Actionsの実行確認**
    - コードをプッシュすると、Actionsタブでワークフローが実行されるのを確認します。

### **11.2. デプロイの設定（AWS ECSを例に）**

1. **Dockerのインストール**
    - [Docker公式サイト](https://www.docker.com/products/docker-desktop)からDocker Desktopをダウンロードし、インストールします。
2. **Dockerfileの作成**
    - **サーバー用の`Dockerfile`の作成**
        
        ```
        # server/Dockerfile
        FROM node:14
        
        WORKDIR /app
        
        COPY package*.json ./
        RUN npm install
        
        COPY . .
        
        RUN npm run build
        
        EXPOSE 5000
        
        CMD ["node", "dist/index.js"]
        
        ```
        
    - **クライアント用の`Dockerfile`の作成**
        
        ```
        # client/Dockerfile
        FROM node:14
        
        WORKDIR /app
        
        COPY package*.json ./
        RUN npm install
        
        COPY . .
        
        RUN npm run build
        
        # Serve the app using a static server
        RUN npm install -g serve
        CMD ["serve", "-s", "dist"]
        
        ```
        
3. **Dockerイメージのビルドとテスト**
    - **サーバーイメージのビルド**
        
        ```bash
        cd server
        docker build -t izumi-server .
        
        ```
        
    - **クライアントイメージのビルド**
        
        ```bash
        cd ../client
        docker build -t izumi-client .
        
        ```
        
    - **ローカルでのコンテナ起動と確認**
        
        ```bash
        docker run -p 5000:5000 izumi-server
        docker run -p 3000:5000 izumi-client
        
        ```
        
        - サーバーが`http://localhost:5000`で、クライアントが`http://localhost:3000`で動作することを確認します。
4. **AWS ECSへのデプロイ**
    - **AWS管理コンソールでECSクラスターの作成**
        - [AWS ECS公式ガイド](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/create-cluster.html)に従ってクラスターを作成します。
    - **タスク定義の作成**
        - サーバーとクライアントのコンテナを定義します。
    - **サービスの作成とデプロイ**
        - 作成したタスク定義を基にサービスを作成し、クラスターにデプロイします。

### **11.3. GitHub Actionsでの自動デプロイ設定（オプション）**

- **CI/CDワークフローにデプロイステップを追加**
    - AWS CLIや他のデプロイツールを使用して、自動的にECSにデプロイするステップを追加します。
    - 詳細は[GitHub Actionsの公式ドキュメント](https://docs.github.com/en/actions)を参照してください。

### **11.4. Gitへのコミット**

```bash
git add .
git commit -m "Set up Docker and GitHub Actions for CI/CD pipeline"
git push

```

---

## **ステップ12: 継続的な開発とフィードバックの収集**

### **12.1. 定期的なコードレビューとテスト**

- **コードの品質を保つために、定期的にコードレビューを行いましょう。**
- **テストカバレッジを増やし、バグの早期発見に努めましょう。**

### **12.2. ユーザーフィードバックの収集**

1. **ベータ版のリリース**
    - 限定的なユーザーにアプリを提供し、フィードバックを収集します。
2. **フィードバックフォームの作成**
    - フロントエンドにフィードバックフォームを追加し、ユーザーからの意見を収集します。

### **12.3. データ分析と改善**

- **ユーザーデータを分析し、利用傾向や問題点を特定します。**
- **分析結果に基づき、機能の改善や新機能の追加を検討します。**

### **12.4. ドキュメントの整備**

- **技術ドキュメントやAPIドキュメントを作成し、開発者間で共有します。**
- **ユーザー向けのガイドやチュートリアルも提供します。**

### **12.5. Gitへのコミット**

```bash
git add .
git commit -m "Set up continuous development practices and user feedback mechanisms"
git push

```

---

## **まとめ**

---

## **ステップ10: 商材管理機能の完成**

### **10.1 商材閲覧機能の実装**

### **バックエンド: 商材一覧取得APIの実装**

1. **`Product`モデルの確認**
    
    既に`Product`モデルが存在していることを前提とします。必要に応じてモデルを拡張してください。
    
2. **商材一覧取得ルートの作成**
    - **`src/routes/product.ts`** に以下のエンドポイントを追加します。
        
        ```tsx
        // src/routes/product.ts
        import { Router, Request, Response } from 'express';
        import Product from '../models/Product';
        
        const router = Router();
        
        // 商材一覧取得API
        router.get('/list', async (req: Request, res: Response) => {
          try {
            const products = await Product.findAll({
              attributes: ['id', 'title', 'description', 'category', 'fileUrl', 'fileType', 'fileSize', 'providerId', 'createdAt'],
            });
            res.status(200).json({ products });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: '商材一覧の取得に失敗しました。' });
          }
        });
        
        export default router;
        
        ```
        
3. **商材詳細取得ルートの作成**
    - **`src/routes/product.ts`** に以下のエンドポイントを追加します。
        
        ```tsx
        // 商材詳細取得API
        router.get('/:id', async (req: Request, res: Response) => {
          const { id } = req.params;
          try {
            const product = await Product.findByPk(id, {
              attributes: ['id', 'title', 'description', 'category', 'fileUrl', 'fileType', 'fileSize', 'providerId', 'createdAt'],
            });
            if (!product) {
              return res.status(404).json({ message: '商材が見つかりませんでした。' });
            }
            res.status(200).json({ product });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: '商材詳細の取得に失敗しました。' });
          }
        });
        
        ```
        
4. **ルートの統合**
    - **`src/index.ts`** に商材ルートを統合します。
        
        ```tsx
        // src/index.ts
        import productRoutes from './routes/product';
        // ... 他のインポート
        
        app.use('/api/product', productRoutes);
        
        // ... 残りのコード
        
        ```
        

### **フロントエンド: 商材リストページの作成**

1. **商材リストページコンポーネントの作成**
    - **`src/pages/ProductList.tsx`** を作成します。
        
        ```tsx
        // src/pages/ProductList.tsx
        import React, { useEffect, useState } from 'react';
        import axios from 'axios';
        import { Container, Typography, Grid, Card, CardContent, CardMedia, Button } from '@mui/material';
        import { Link } from 'react-router-dom';
        
        const ProductList: React.FC = () => {
          const [products, setProducts] = useState<any[]>([]);
          const [message, setMessage] = useState('');
        
          useEffect(() => {
            const fetchProducts = async () => {
              try {
                const res = await axios.get('/api/product/list');
                setProducts(res.data.products);
              } catch (error: any) {
                setMessage(error.response?.data?.message || '商材の取得に失敗しました。');
              }
            };
        
            fetchProducts();
          }, []);
        
          return (
            <Container>
              <Typography variant="h4" gutterBottom>
                商材一覧
              </Typography>
              {message && <Typography variant="body1">{message}</Typography>}
              <Grid container spacing={4}>
                {products.map((product) => (
                  <Grid item key={product.id} xs={12} sm={6} md={4}>
                    <Card>
                      {product.fileType === 'image' && (
                        <CardMedia
                          component="img"
                          height="140"
                          image={product.fileUrl}
                          alt={product.title}
                        />
                      )}
                      <CardContent>
                        <Typography gutterBottom variant="h5" component="div">
                          {product.title}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          {product.description.substring(0, 100)}...
                        </Typography>
                        <Button
                          component={Link}
                          to={`/product/${product.id}`}
                          variant="contained"
                          color="primary"
                          style={{ marginTop: '10px' }}
                        >
                          詳細を見る
                        </Button>
                      </CardContent>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            </Container>
          );
        };
        
        export default ProductList;
        
        ```
        
2. **ルーティングの追加**
    - **`src/main.tsx`** に商材リストページのルートを追加します。
        
        ```tsx
        // src/main.tsx
        import ProductList from './pages/ProductList';
        // ... 他のインポート
        
        ReactDOM.render(
          <React.StrictMode>
            <Router>
              <Routes>
                <Route path="/" element={<App />} />
                <Route path="/register" element={<Register />} />
                <Route path="/login" element={<Login />} />
                <Route path="/profile" element={<Profile />} />
                <Route path="/subscription" element={<Subscription />} />
                <Route path="/ai" element={<AIProcessing />} />
                <Route path="/revenue-report" element={<RevenueReport />} />
                <Route path="/product/:productId" element={<ProductDetail />} />
                <Route path="/admin" element={<Admin />} />
                <Route path="/upload" element={<UploadProduct />} />
                <Route path="/products" element={<ProductList />} />
              </Routes>
            </Router>
          </React.StrictMode>,
          document.getElementById('root')
        );
        
        ```
        
3. **ナビゲーションの更新**
    - **`App.tsx`** に商材リストページへのリンクを追加します。
        
        ```tsx
        // src/App.tsx
        // ... 既存のインポート
        import { useTranslation } from 'react-i18next';
        
        const App: React.FC = () => {
          const { t } = useTranslation();
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  <LanguageSwitcher />
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        {t('Register')}
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        {t('Login')}
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        {t('Profile')}
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        {t('Subscription')}
                      </Button>
                      <Button color="inherit" component={Link} to="/ai">
                        {t('AI Processing')}
                      </Button>
                      <Button color="inherit" component={Link} to="/products">
                        {t('Products')}
                      </Button>
                      <Button color="inherit" component={Link} to="/revenue-report">
                        {t('Revenue Report')}
                      </Button>
                      <Button color="inherit" component={Link} to="/feedback">
                        {t('User Feedback')}
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          {t('Admin')}
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          {t('Upload Product')}
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                {t('Welcome')}
              </Typography>
              <AdBanner />
              <footer style={{ marginTop: '50px', padding: '20px', backgroundColor: '#f5f5f5', textAlign: 'center' }}>
                <Typography variant="body2">
                  <Link to="/terms">利用規約</Link> | <Link to="/privacy">プライバシーポリシー</Link> | <Link to="/feedback">フィードバック</Link>
                </Typography>
              </footer>
            </div>
          );
        };
        
        export default App;
        
        ```
        

### **フロントエンド: 商材詳細ページの作成**

1. **商材詳細ページコンポーネントの作成**
    - **`src/pages/ProductDetail.tsx`** を作成します。
        
        ```tsx
        // src/pages/ProductDetail.tsx
        import React, { useEffect, useState } from 'react';
        import axios from 'axios';
        import { useParams } from 'react-router-dom';
        import { Container, Typography, Card, CardContent, CardMedia, Button } from '@mui/material';
        
        const ProductDetail: React.FC = () => {
          const { productId } = useParams();
          const [product, setProduct] = useState<any>(null);
          const [message, setMessage] = useState('');
        
          useEffect(() => {
            const fetchProduct = async () => {
              try {
                const res = await axios.get(`/api/product/${productId}`);
                setProduct(res.data.product);
              } catch (error: any) {
                setMessage(error.response?.data?.message || '商材の取得に失敗しました。');
              }
            };
        
            fetchProduct();
          }, [productId]);
        
          const handleDownload = async () => {
            const token = localStorage.getItem('token');
            try {
              const res = await axios.get(`/api/download/${productId}`, {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
                responseType: 'blob',
              });
              const url = window.URL.createObjectURL(new Blob([res.data]));
              const link = document.createElement('a');
              link.href = url;
              link.setAttribute('download', `${product.title}.${product.fileType}`);
              document.body.appendChild(link);
              link.click();
              link.parentNode?.removeChild(link);
              setMessage('ダウンロードを開始しました。');
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'ダウンロードに失敗しました。');
            }
          };
        
          if (!product) {
            return (
              <Container>
                <Typography variant="h6">{message || '読み込み中...'}</Typography>
              </Container>
            );
          }
        
          return (
            <Container>
              <Card>
                {product.fileType === 'image' && (
                  <CardMedia
                    component="img"
                    height="300"
                    image={product.fileUrl}
                    alt={product.title}
                  />
                )}
                <CardContent>
                  <Typography gutterBottom variant="h5" component="div">
                    {product.title}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {product.description}
                  </Typography>
                  <Typography variant="subtitle1" gutterBottom>
                    カテゴリー: {product.category}
                  </Typography>
                  <Button
                    variant="contained"
                    color="primary"
                    onClick={handleDownload}
                    disabled={!product.isPurchased} // 購入済みかどうかのフラグ
                  >
                    ダウンロード
                  </Button>
                  {!product.isPurchased && (
                    <Typography variant="body2" color="error" style={{ marginTop: '10px' }}>
                      ダウンロードには購入が必要です。
                    </Typography>
                  )}
                  {message && <Typography variant="body1" style={{ marginTop: '10px' }}>{message}</Typography>}
                </CardContent>
              </Card>
            </Container>
          );
        };
        
        export default ProductDetail;
        
        ```
        
2. **ルーティングの確認**
    
    既に`src/main.tsx`で商材詳細ページのルートが追加されていることを確認してください。
    
    ```tsx
    <Route path="/product/:productId" element={<ProductDetail />} />
    
    ```
    
3. **購入済みユーザーのみダウンロードを許可するロジックの実装**
    - **バックエンドでの購入確認**
        
        ダウンロードAPIにおいて、ユーザーが該当商材を購入済みであることを確認するロジックを追加します。
        
        ```tsx
        // src/routes/download.ts
        import { Router, Request, Response } from 'express';
        import { authenticateToken } from '../middleware/authMiddleware';
        import Product from '../models/Product';
        import DownloadHistory from '../models/DownloadHistory';
        import Purchase from '../models/Purchase'; // 購入履歴モデル
        
        const router = Router();
        
        // 商材ダウンロードAPI
        router.get('/:productId', authenticateToken, async (req: Request, res: Response) => {
          const { productId } = req.params;
          const userId = req.user.id;
        
          try {
            const product = await Product.findByPk(productId);
            if (!product) {
              return res.status(404).json({ message: '商材が見つかりませんでした。' });
            }
        
            // ユーザーが商材を購入しているか確認
            const purchase = await Purchase.findOne({
              where: {
                userId,
                productId,
                status: 'completed', // 購入ステータスが完了していること
              },
            });
        
            if (!purchase) {
              return res.status(403).json({ message: '購入済みの商材のみダウンロード可能です。' });
            }
        
            // ダウンロード履歴の記録
            await DownloadHistory.create({
              userId,
              productId: product.id,
              downloadDate: new Date(),
              duration: 0, // 必要に応じてフロントエンドから更新
            });
        
            // ファイルの送信（DRM保護前提）
            // DRM保護の具体的な実装は別途検討
            res.setHeader('Content-Disposition', `attachment; filename="${product.title}.${product.fileType}"`);
            res.setHeader('Content-Type', product.fileType === 'pdf' ? 'application/pdf' : product.fileType === 'mp4' ? 'video/mp4' : 'audio/mpeg');
            res.sendFile(product.fileUrl, { root: '.' }); // ファイルパスに応じて調整
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'ダウンロードに失敗しました。' });
          }
        });
        
        export default router;
        
        ```
        
    - **購入履歴モデルの作成**
        
        ユーザーの購入履歴を管理する`Purchase`モデルを作成します。
        
        ```tsx
        // src/models/Purchase.ts
        import { DataTypes, Model } from 'sequelize';
        import sequelize from '../config/database';
        import User from './User';
        import Product from './Product';
        
        class Purchase extends Model {
          public id!: number;
          public userId!: number;
          public productId!: number;
          public status!: string; // 'pending', 'completed', 'failed'
          public transactionId!: string;
          public readonly createdAt!: Date;
          public readonly updatedAt!: Date;
        }
        
        Purchase.init(
          {
            id: {
              type: DataTypes.INTEGER,
              autoIncrement: true,
              primaryKey: true,
            },
            userId: {
              type: DataTypes.INTEGER,
              allowNull: false,
              references: {
                model: User,
                key: 'id',
              },
            },
            productId: {
              type: DataTypes.INTEGER,
              allowNull: false,
              references: {
                model: Product,
                key: 'id',
              },
            },
            status: {
              type: DataTypes.STRING,
              allowNull: false,
              defaultValue: 'pending',
            },
            transactionId: {
              type: DataTypes.STRING,
              allowNull: false,
            },
          },
          {
            sequelize,
            tableName: 'purchases',
          }
        );
        
        User.hasMany(Purchase, { foreignKey: 'userId', as: 'purchases' });
        Product.hasMany(Purchase, { foreignKey: 'productId', as: 'purchases' });
        Purchase.belongsTo(User, { foreignKey: 'userId', as: 'user' });
        Purchase.belongsTo(Product, { foreignKey: 'productId', as: 'product' });
        
        export default Purchase;
        
        ```
        
4. **DRM保護機能の検討と実装**
    
    DRM（デジタル著作権管理）の実装は複雑であり、以下の点を考慮する必要があります。
    
    - **ライセンスサーバーの構築**: コンテンツの使用許可を管理するサーバー。
    - **暗号化**: 商材ファイルを暗号化し、認証されたユーザーのみがアクセス可能にする。
    - **ライブラリの利用**: DRM機能を提供するサードパーティライブラリやサービスの利用検討。
    
    具体的な実装はプロジェクトの要件や予算に応じて選定してください。一般的なアプローチとしては、Google WidevineやMicrosoft PlayReadyなどの既存のDRMソリューションを利用する方法があります。
    

### **10.2 ダウンロード機能の実装**

### **バックエンド: 商材ダウンロードAPIの実装**

上記の**10.1 バックエンド**セクションでダウンロードAPIの実装を行いました。以下に補足します。

1. **DRM保護の実装**
    
    DRM保護の具体的な実装は、選定したDRMソリューションに依存します。一般的な手順は以下の通りです。
    
    - **コンテンツの暗号化**: 商材ファイルをDRMプロバイダーのツールを使用して暗号化します。
    - **ライセンスの発行**: ユーザーがダウンロードした際にライセンスを発行し、コンテンツの再生を許可します。
    - **フロントエンドでの再生**: 再生プレイヤーにライセンスを提供し、暗号化されたコンテンツを再生します。
    
    詳細な実装は選定したDRMプロバイダーのドキュメントを参照してください。
    

### **フロントエンド: ダウンロードボタンの追加と状態表示**

1. **商材詳細ページへの「ダウンロード」ボタンの追加**
    
    既に**10.1 フロントエンド**セクションで`Download`ボタンを追加しています。以下に再度確認します。
    
    ```tsx
    // src/pages/ProductDetail.tsx
    <Button
      variant="contained"
      color="primary"
      onClick={handleDownload}
      disabled={!product.isPurchased} // 購入済みかどうかのフラグ
    >
      ダウンロード
    </Button>
    {!product.isPurchased && (
      <Typography variant="body2" color="error" style={{ marginTop: '10px' }}>
        ダウンロードには購入が必要です。
      </Typography>
    )}
    
    ```
    
2. **ダウンロード可能状態の表示**
    
    `product.isPurchased`フラグを利用して、ユーザーが商材を購入済みかどうかを表示しています。バックエンドから商材情報を取得する際に、このフラグを含めるようにします。
    
    - **商材詳細取得APIの修正**
        
        ```tsx
        // src/routes/product.ts
        router.get('/:id', async (req: Request, res: Response) => {
          const { id } = req.params;
          const userId = req.user?.id; // 認証されている場合
          try {
            const product = await Product.findByPk(id, {
              attributes: ['id', 'title', 'description', 'category', 'fileUrl', 'fileType', 'fileSize', 'providerId', 'createdAt'],
            });
            if (!product) {
              return res.status(404).json({ message: '商材が見つかりませんでした。' });
            }
        
            // ユーザーが商材を購入しているか確認
            let isPurchased = false;
            if (userId) {
              const purchase = await Purchase.findOne({
                where: {
                  userId,
                  productId: product.id,
                  status: 'completed',
                },
              });
              if (purchase) {
                isPurchased = true;
              }
            }
        
            res.status(200).json({ product: { ...product.toJSON(), isPurchased } });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: '商材詳細の取得に失敗しました。' });
          }
        });
        
        ```
        

### **10.3 商材管理UIの改善**

### **フロントエンド: 商材アップロードページのUI/UX向上とプレビュー機能の追加**

1. **商材アップロードページのUI/UX向上**
    - **`src/pages/UploadProduct.tsx`** の改善ポイント：
        - **フォームの整理**: 入力フィールドの順序やレイアウトを見直し、ユーザーが直感的に操作できるようにします。
        - **バリデーションの強化**: フロントエンドでの入力バリデーションを追加し、ユーザーの入力ミスを減らします。
        - **フィードバックの提供**: アップロード中のローディングインジケーターや成功・失敗メッセージを表示します。
2. **プレビュー機能の追加（例: サムネイル表示）**
    - **商材ファイルのプレビュー**
        - **画像の場合**: サムネイルを表示します。
        - **動画の場合**: サムネイル画像やプレビュー動画を表示します。
        - **音声の場合**: サムネイル画像や波形表示を検討します。
    - **実装例: サムネイル表示**
        
        ```tsx
        // src/pages/UploadProduct.tsx
        import React, { useState } from 'react';
        import axios from 'axios';
        import { TextField, Button, Container, Typography, Select, MenuItem, InputLabel, FormControl, CircularProgress } from '@mui/material';
        
        const UploadProduct: React.FC = () => {
          const [title, setTitle] = useState('');
          const [description, setDescription] = useState('');
          const [category, setCategory] = useState('');
          const [file, setFile] = useState<File | null>(null);
          const [preview, setPreview] = useState<string>('');
          const [message, setMessage] = useState('');
          const [loading, setLoading] = useState(false);
        
          const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
            if (e.target.files && e.target.files[0]) {
              const selectedFile = e.target.files[0];
              setFile(selectedFile);
        
              // プレビューの生成
              const reader = new FileReader();
              reader.onloadend = () => {
                setPreview(reader.result as string);
              };
              if (selectedFile.type.startsWith('image/')) {
                reader.readAsDataURL(selectedFile);
              } else {
                // 画像以外はサムネイル画像を設定（デフォルト）
                setPreview('/default-thumbnail.png'); // プロジェクトにデフォルト画像を追加
              }
            }
          };
        
          const handleUpload = async (e: React.FormEvent) => {
            e.preventDefault();
            if (!file) {
              setMessage('ファイルを選択してください。');
              return;
            }
        
            setLoading(true);
            const token = localStorage.getItem('token');
            const formData = new FormData();
            formData.append('title', title);
            formData.append('description', description);
            formData.append('category', category);
            formData.append('file', file);
        
            try {
              const res = await axios.post('/api/product/upload', formData, {
                headers: {
                  'Content-Type': 'multipart/form-data',
                  Authorization: `Bearer ${token}`,
                },
              });
              setMessage('商材をアップロードしました。');
              setTitle('');
              setDescription('');
              setCategory('');
              setFile(null);
              setPreview('');
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'アップロードに失敗しました。');
            } finally {
              setLoading(false);
            }
          };
        
          return (
            <Container maxWidth="sm">
              <Typography variant="h4" gutterBottom>
                商材アップロード
              </Typography>
              <form onSubmit={handleUpload}>
                <TextField
                  label="タイトル"
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  required
                />
                <TextField
                  label="説明"
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  multiline
                  rows={4}
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  required
                />
                <FormControl fullWidth margin="normal">
                  <InputLabel>カテゴリー</InputLabel>
                  <Select value={category} onChange={(e) => setCategory(e.target.value as string)} required>
                    <MenuItem value="Education">Education</MenuItem>
                    <MenuItem value="Business">Business</MenuItem>
                    <MenuItem value="Lifestyle">Lifestyle</MenuItem>
                    {/* 必要に応じてカテゴリーを追加 */}
                  </Select>
                </FormControl>
                <Button variant="contained" component="label" fullWidth style={{ marginTop: '20px' }}>
                  ファイル選択
                  <input
                    type="file"
                    hidden
                    onChange={handleFileChange}
                    accept="image/*,video/*,audio/*,application/pdf"
                  />
                </Button>
                {file && <Typography variant="body1" style={{ marginTop: '10px' }}>{file.name}</Typography>}
                {preview && (
                  <img src={preview} alt="プレビュー" style={{ width: '100%', marginTop: '20px' }} />
                )}
                <Button type="submit" variant="contained" color="primary" fullWidth style={{ marginTop: '20px' }} disabled={loading}>
                  {loading ? <CircularProgress size={24} color="inherit" /> : 'アップロード'}
                </Button>
              </form>
              {message && <Typography variant="body1" style={{ marginTop: '20px' }}>{message}</Typography>}
            </Container>
          );
        };
        
        export default UploadProduct;
        
        ```
        
3. **プレビュー機能の説明**
    - **画像プレビュー**: ユーザーが画像ファイルをアップロードした際に、即座にプレビューを表示します。
    - **非画像ファイルの場合**: デフォルトのサムネイル画像を表示し、ユーザーにファイルタイプを視覚的に認識させます。
4. **スタイリングの改善**
    
    Material-UI（MUI）のコンポーネントを活用し、レスポンシブでユーザーフレンドリーなUIを実現します。必要に応じてカスタムスタイルを追加してください。
    

### **10.4 Gitへのコミット**

すべての変更が完了したら、以下のコマンドで変更をステージングし、コミット・プッシュします。

```bash
git add .
git commit -m "Implement product viewing features, download functionality, and enhance product management UI with preview"
git push

```

---

以上で、**ステップ10: 商材管理機能の完成**に関する実装が完了しました。各セクションで提供したコードスニペットや手順を参考に、プロジェクトに適用してください。何か質問や追加のサポートが必要な場合は、お気軽にお知らせください。

---

## **ステップ10: サブスクリプション管理機能の実装**

### **10.1. バックエンドでのサブスクリプションモデルの作成**

1. **サブスクリプションモデルの作成**
    - **`Subscription.ts`の作成**
        
        ```tsx
        // src/models/Subscription.ts
        import { DataTypes, Model } from 'sequelize';
        import sequelize from '../config/database';
        import User from './User';
        
        class Subscription extends Model {
          public id!: number;
          public userId!: number;
          public plan!: string; // 'Basic', 'Pro', 'Premium'
          public status!: string; // 'active', 'canceled'
          public startDate!: Date;
          public endDate!: Date | null;
          public readonly createdAt!: Date;
          public readonly updatedAt!: Date;
        }
        
        Subscription.init(
          {
            id: {
              type: DataTypes.INTEGER,
              autoIncrement: true,
              primaryKey: true,
            },
            userId: {
              type: DataTypes.INTEGER,
              allowNull: false,
              references: {
                model: User,
                key: 'id',
              },
            },
            plan: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            status: {
              type: DataTypes.STRING,
              allowNull: false,
              defaultValue: 'active',
            },
            startDate: {
              type: DataTypes.DATE,
              allowNull: false,
              defaultValue: DataTypes.NOW,
            },
            endDate: {
              type: DataTypes.DATE,
              allowNull: true,
            },
          },
          {
            sequelize,
            tableName: 'subscriptions',
          }
        );
        
        User.hasOne(Subscription, { foreignKey: 'userId', as: 'subscription' });
        Subscription.belongsTo(User, { foreignKey: 'userId', as: 'user' });
        
        export default Subscription;
        
        ```
        
2. **データベースへのモデル同期**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import sequelize from './config/database';
        import User from './models/User';
        import Product from './models/Product';
        import Subscription from './models/Subscription';
        import authRoutes from './routes/auth';
        import profileRoutes from './routes/profile';
        import adminRoutes from './routes/admin';
        import productRoutes from './routes/product';
        import subscriptionRoutes from './routes/subscription';
        import cors from 'cors';
        
        const app = express();
        const PORT = process.env.PORT || 5000;
        
        app.use(cors());
        app.use(express.json());
        
        app.use('/api/auth', authRoutes);
        app.use('/api/profile', profileRoutes);
        app.use('/api/admin', adminRoutes);
        app.use('/api/product', productRoutes);
        app.use('/api/subscription', subscriptionRoutes);
        
        app.get('/', (req, res) => {
          res.send('Hello izumi!');
        });
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        app.listen(PORT, () => {
          console.log(`Server is running on port ${PORT}`);
        });
        
        ```
        
3. **サブスクリプションルートの作成**
    - **`subscription.ts`の作成**
        
        ```tsx
        // src/routes/subscription.ts
        import { Router, Request, Response } from 'express';
        import { authenticateToken } from '../middleware/authMiddleware';
        import Subscription from '../models/Subscription';
        
        const router = Router();
        
        // サブスクリプション登録
        router.post('/subscribe', authenticateToken, async (req: Request, res: Response) => {
          const { plan } = req.body;
          const userId = req.user.id;
        
          // プランのバリデーション
          const validPlans = ['Basic', 'Pro', 'Premium'];
          if (!validPlans.includes(plan)) {
            return res.status(400).json({ message: 'Invalid subscription plan.' });
          }
        
          try {
            // 既存のサブスクリプションを確認
            const existingSubscription = await Subscription.findOne({ where: { userId } });
            if (existingSubscription) {
              return res.status(400).json({ message: 'Subscription already exists.' });
            }
        
            // サブスクリプションの作成
            const subscription = await Subscription.create({
              userId,
              plan,
              status: 'active',
              startDate: new Date(),
              endDate: null,
            });
        
            res.status(201).json({ message: 'Subscribed successfully.', subscription });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        // サブスクリプションの変更
        router.put('/change', authenticateToken, async (req: Request, res: Response) => {
          const { plan } = req.body;
          const userId = req.user.id;
        
          // プランのバリデーション
          const validPlans = ['Basic', 'Pro', 'Premium'];
          if (!validPlans.includes(plan)) {
            return res.status(400).json({ message: 'Invalid subscription plan.' });
          }
        
          try {
            const subscription = await Subscription.findOne({ where: { userId } });
            if (!subscription) {
              return res.status(404).json({ message: 'Subscription not found.' });
            }
        
            subscription.plan = plan;
            await subscription.save();
        
            res.status(200).json({ message: 'Subscription plan updated successfully.', subscription });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        // サブスクリプションの解約
        router.post('/cancel', authenticateToken, async (req: Request, res: Response) => {
          const userId = req.user.id;
        
          try {
            const subscription = await Subscription.findOne({ where: { userId } });
            if (!subscription) {
              return res.status(404).json({ message: 'Subscription not found.' });
            }
        
            subscription.status = 'canceled';
            subscription.endDate = new Date();
            await subscription.save();
        
            res.status(200).json({ message: 'Subscription canceled successfully.', subscription });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Server error.' });
          }
        });
        
        export default router;
        
        ```
        
4. **フロントエンドでのサブスクリプションページの作成**
    - **`Subscription.tsx`の作成**
        
        ```tsx
        // src/pages/Subscription.tsx
        import React, { useState, useEffect } from 'react';
        import axios from 'axios';
        import { Container, Typography, Button, Select, MenuItem, InputLabel, FormControl } from '@mui/material';
        
        const Subscription: React.FC = () => {
          const [plan, setPlan] = useState('');
          const [message, setMessage] = useState('');
          const [currentPlan, setCurrentPlan] = useState('');
          const [subscription, setSubscription] = useState<any>(null);
        
          useEffect(() => {
            const fetchSubscription = async () => {
              const token = localStorage.getItem('token');
              try {
                const res = await axios.get('/api/subscription/', {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                });
                setSubscription(res.data.subscription);
                setCurrentPlan(res.data.subscription.plan);
              } catch (error: any) {
                setMessage(error.response?.data?.message || 'Failed to fetch subscription.');
              }
            };
        
            fetchSubscription();
          }, []);
        
          const handleSubscribe = async () => {
            const token = localStorage.getItem('token');
            try {
              const res = await axios.post(
                '/api/subscription/subscribe',
                { plan },
                {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                }
              );
              setMessage(res.data.message);
              setSubscription(res.data.subscription);
              setCurrentPlan(res.data.subscription.plan);
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Subscription failed.');
            }
          };
        
          const handleChangePlan = async () => {
            const token = localStorage.getItem('token');
            try {
              const res = await axios.put(
                '/api/subscription/change',
                { plan },
                {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                }
              );
              setMessage(res.data.message);
              setSubscription(res.data.subscription);
              setCurrentPlan(res.data.subscription.plan);
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Plan change failed.');
            }
          };
        
          const handleCancel = async () => {
            const token = localStorage.getItem('token');
            try {
              const res = await axios.post(
                '/api/subscription/cancel',
                {},
                {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                }
              );
              setMessage(res.data.message);
              setSubscription(res.data.subscription);
              setCurrentPlan('');
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Cancellation failed.');
            }
          };
        
          return (
            <Container maxWidth="sm">
              <Typography variant="h4" gutterBottom>
                Subscription
              </Typography>
              {currentPlan ? (
                <div>
                  <Typography variant="h6">Current Plan: {currentPlan}</Typography>
                  <FormControl fullWidth margin="normal">
                    <InputLabel>Change Plan</InputLabel>
                    <Select value={plan} onChange={(e) => setPlan(e.target.value as string)}>
                      <MenuItem value="Basic">Basic - ¥890/月（広告あり）</MenuItem>
                      <MenuItem value="Pro">Pro - ¥1,280/月（広告なし）</MenuItem>
                      <MenuItem value="Premium">Premium - ¥1,980/月（AI制限なし・広告なし）</MenuItem>
                    </Select>
                  </FormControl>
                  <Button variant="contained" color="primary" onClick={handleChangePlan} fullWidth style={{ marginTop: '10px' }}>
                    Change Plan
                  </Button>
                  <Button variant="outlined" color="secondary" onClick={handleCancel} fullWidth style={{ marginTop: '10px' }}>
                    Cancel Subscription
                  </Button>
                </div>
              ) : (
                <div>
                  <FormControl fullWidth margin="normal">
                    <InputLabel>Choose Plan</InputLabel>
                    <Select value={plan} onChange={(e) => setPlan(e.target.value as string)}>
                      <MenuItem value="Basic">Basic - ¥890/月（広告あり）</MenuItem>
                      <MenuItem value="Pro">Pro - ¥1,280/月（広告なし）</MenuItem>
                      <MenuItem value="Premium">Premium - ¥1,980/月（AI制限なし・広告なし）</MenuItem>
                    </Select>
                  </FormControl>
                  <Button variant="contained" color="primary" onClick={handleSubscribe} fullWidth style={{ marginTop: '10px' }}>
                    Subscribe
                  </Button>
                </div>
              )}
              {message && <Typography variant="body1" style={{ marginTop: '20px' }}>{message}</Typography>}
            </Container>
          );
        };
        
        export default Subscription;
        
        ```
        
5. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import React from 'react';
        import ReactDOM from 'react-dom';
        import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
        import App from './App';
        import Register from './pages/Register';
        import Login from './pages/Login';
        import Profile from './pages/Profile';
        import Admin from './pages/Admin';
        import UploadProduct from './pages/UploadProduct';
        import Subscription from './pages/Subscription';
        
        ReactDOM.render(
          <React.StrictMode>
            <Router>
              <Routes>
                <Route path="/" element={<App />} />
                <Route path="/register" element={<Register />} />
                <Route path="/login" element={<Login />} />
                <Route path="/profile" element={<Profile />} />
                <Route path="/admin" element={<Admin />} />
                <Route path="/upload" element={<UploadProduct />} />
                <Route path="/subscription" element={<Subscription />} />
              </Routes>
            </Router>
          </React.StrictMode>,
          document.getElementById('root')
        );
        
        ```
        
6. **ナビゲーションの更新**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        
        const App: React.FC = () => {
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        Register
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        Login
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        Profile
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        Subscription
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          Admin
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          Upload Product
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                Welcome to izumi
              </Typography>
            </div>
          );
        };
        
        export default App;
        
        ```
        
7. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement subscription management features with backend and frontend integration"
    git push
    
    ```
    

---

## **ステップ11: AI機能の実装**

### **11.1. 必要なパッケージのインストール**

1. **バックエンドでのAI関連パッケージのインストール**
    
    ```bash
    cd server
    npm install @google-cloud/speech @google-cloud/text-to-speech @google-cloud/translate
    npm install --save-dev @types/google-cloud__speech @types/google-cloud__text-to-speech @types/google-cloud__translate
    
    ```
    
2. **環境変数の設定**
    - **`.env`ファイルの作成**
        
        ```
        GOOGLE_APPLICATION_CREDENTIALS=path/to/your/google-credentials.json
        GEMINI_API_KEY=your_gemini_api_key
        
        ```
        
    - **`dotenv`の設定**
        
        ```bash
        npm install dotenv
        npm install --save-dev @types/dotenv
        
        ```
        
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import express from 'express';
        import dotenv from 'dotenv';
        // ... 他のインポート
        
        dotenv.config();
        
        // 残りのコードは既存のまま
        
        ```
        

### **11.2. AI処理用のルートの作成**

1. **`ai.ts`の作成**
    
    ```tsx
    // src/routes/ai.ts
    import { Router, Request, Response } from 'express';
    import { authenticateToken } from '../middleware/authMiddleware';
    import speech from '@google-cloud/speech';
    import textToSpeech from '@google-cloud/text-to-speech';
    import { Translate } from '@google-cloud/translate';
    import fs from 'fs';
    import util from 'util';
    
    const router = Router();
    
    // Google Cloudクライアントの初期化
    const speechClient = new speech.SpeechClient();
    const ttsClient = new textToSpeech.TextToSpeechClient();
    const translateClient = new Translate();
    
    // 音声からテキストへの変換
    router.post('/speech-to-text', authenticateToken, async (req: Request, res: Response) => {
      const { audioContent } = req.body; // base64エンコードされた音声データ
    
      try {
        const buffer = Buffer.from(audioContent, 'base64');
    
        const audio = {
          content: buffer.toString('base64'),
        };
        const config = {
          encoding: 'MP3',
          languageCode: 'ja-JP',
        };
        const request = {
          audio,
          config,
        };
    
        const [response] = await speechClient.recognize(request);
        const transcription = response.results
          .map(result => result.alternatives[0].transcript)
          .join('\n');
        res.status(200).json({ transcription });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Speech-to-Text conversion failed.' });
      }
    });
    
    // テキストの翻訳
    router.post('/translate', authenticateToken, async (req: Request, res: Response) => {
      const { text, targetLanguage } = req.body;
    
      try {
        const [translation] = await translateClient.translate(text, targetLanguage);
        res.status(200).json({ translation });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Translation failed.' });
      }
    });
    
    // テキストから音声への変換
    router.post('/text-to-speech', authenticateToken, async (req: Request, res: Response) => {
      const { text, languageCode } = req.body;
    
      try {
        const request = {
          input: { text },
          // Select the language and SSML voice gender (optional)
          voice: { languageCode, ssmlGender: 'NEUTRAL' },
          // Select the type of audio encoding
          audioConfig: { audioEncoding: 'MP3' },
        };
    
        const [response] = await ttsClient.synthesizeSpeech(request);
        res.set('Content-Type', 'audio/mpeg');
        res.send(response.audioContent);
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Text-to-Speech conversion failed.' });
      }
    });
    
    export default router;
    
    ```
    
2. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import aiRoutes from './routes/ai';
        
        // ... 既存のコード
        
        app.use('/api/ai', aiRoutes);
        
        // 残りのコードは既存のまま
        
        ```
        

### **11.3. フロントエンドでのAI機能の実装**

1. **AI処理ページの作成**
    - **`AIProcessing.tsx`の作成**
        
        ```tsx
        // src/pages/AIProcessing.tsx
        import React, { useState } from 'react';
        import axios from 'axios';
        import { Container, Typography, TextField, Button } from '@mui/material';
        
        const AIProcessing: React.FC = () => {
          const [audioFile, setAudioFile] = useState<File | null>(null);
          const [transcription, setTranscription] = useState('');
          const [translatedText, setTranslatedText] = useState('');
          const [audioOutput, setAudioOutput] = useState<string>('');
          const [message, setMessage] = useState('');
        
          const handleSpeechToText = async () => {
            if (!audioFile) {
              setMessage('Please upload an audio file.');
              return;
            }
        
            const reader = new FileReader();
            reader.readAsDataURL(audioFile);
            reader.onloadend = async () => {
              const base64data = reader.result?.toString().split(',')[1];
              try {
                const res = await axios.post('/api/ai/speech-to-text', { audioContent: base64data });
                setTranscription(res.data.transcription);
              } catch (error: any) {
                setMessage(error.response?.data?.message || 'Speech-to-Text failed.');
              }
            };
          };
        
          const handleTranslate = async () => {
            if (!transcription) {
              setMessage('No transcription available to translate.');
              return;
            }
        
            try {
              const res = await axios.post('/api/ai/translate', { text: transcription, targetLanguage: 'en' });
              setTranslatedText(res.data.translation);
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Translation failed.');
            }
          };
        
          const handleTextToSpeech = async () => {
            if (!translatedText) {
              setMessage('No translated text available for Text-to-Speech.');
              return;
            }
        
            try {
              const res = await axios.post(
                '/api/ai/text-to-speech',
                { text: translatedText, languageCode: 'en-US' },
                { responseType: 'blob' }
              );
              const audioUrl = URL.createObjectURL(new Blob([res.data], { type: 'audio/mpeg' }));
              setAudioOutput(audioUrl);
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Text-to-Speech failed.');
            }
          };
        
          return (
            <Container maxWidth="sm">
              <Typography variant="h4" gutterBottom>
                AI Processing
              </Typography>
              <input
                accept="audio/*"
                style={{ display: 'none' }}
                id="audio-upload"
                type="file"
                onChange={(e) => {
                  if (e.target.files && e.target.files[0]) {
                    setAudioFile(e.target.files[0]);
                  }
                }}
              />
              <label htmlFor="audio-upload">
                <Button variant="contained" component="span" fullWidth>
                  Upload Audio File
                </Button>
              </label>
              {audioFile && <Typography variant="body1" style={{ marginTop: '10px' }}>{audioFile.name}</Typography>}
              <Button variant="contained" color="primary" onClick={handleSpeechToText} fullWidth style={{ marginTop: '20px' }}>
                Convert Speech to Text
              </Button>
              {transcription && (
                <div style={{ marginTop: '20px' }}>
                  <Typography variant="h6">Transcription:</Typography>
                  <Typography variant="body1">{transcription}</Typography>
                  <Button variant="contained" color="primary" onClick={handleTranslate} fullWidth style={{ marginTop: '10px' }}>
                    Translate to English
                  </Button>
                </div>
              )}
              {translatedText && (
                <div style={{ marginTop: '20px' }}>
                  <Typography variant="h6">Translated Text:</Typography>
                  <Typography variant="body1">{translatedText}</Typography>
                  <Button variant="contained" color="primary" onClick={handleTextToSpeech} fullWidth style={{ marginTop: '10px' }}>
                    Convert Text to Speech
                  </Button>
                </div>
              )}
              {audioOutput && (
                <div style={{ marginTop: '20px' }}>
                  <Typography variant="h6">Audio Output:</Typography>
                  <audio controls src={audioOutput}></audio>
                </div>
              )}
              {message && <Typography variant="body1" style={{ marginTop: '20px' }}>{message}</Typography>}
            </Container>
          );
        };
        
        export default AIProcessing;
        
        ```
        
2. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import AIProcessing from './pages/AIProcessing';
        
        // ... 既存のコード
        
        <Route path="/ai" element={<AIProcessing />} />
        
        // ... 残りのコード
        
        ```
        
3. **ナビゲーションの更新**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        
        const App: React.FC = () => {
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        Register
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        Login
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        Profile
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        Subscription
                      </Button>
                      <Button color="inherit" component={Link} to="/ai">
                        AI Processing
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          Admin
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          Upload Product
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                Welcome to izumi
              </Typography>
            </div>
          );
        };
        
        export default App;
        
        ```
        
4. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement AI functionalities including speech-to-text, translation, and text-to-speech"
    git push
    
    ```
    

---

## **ステップ12: ダウンロード機能の実装**

### **12.1. ダウンロードモデルの作成**

1. **ダウンロード履歴モデルの作成**
    - **`DownloadHistory.ts`の作成**
        
        ```tsx
        // src/models/DownloadHistory.ts
        import { DataTypes, Model } from 'sequelize';
        import sequelize from '../config/database';
        import User from './User';
        import Product from './Product';
        
        class DownloadHistory extends Model {
          public id!: number;
          public userId!: number;
          public productId!: number;
          public downloadDate!: Date;
          public duration!: number; // 利用時間（秒）
          public readonly createdAt!: Date;
          public readonly updatedAt!: Date;
        }
        
        DownloadHistory.init(
          {
            id: {
              type: DataTypes.INTEGER,
              autoIncrement: true,
              primaryKey: true,
            },
            userId: {
              type: DataTypes.INTEGER,
              allowNull: false,
              references: {
                model: User,
                key: 'id',
              },
            },
            productId: {
              type: DataTypes.INTEGER,
              allowNull: false,
              references: {
                model: Product,
                key: 'id',
              },
            },
            downloadDate: {
              type: DataTypes.DATE,
              allowNull: false,
              defaultValue: DataTypes.NOW,
            },
            duration: {
              type: DataTypes.INTEGER,
              allowNull: false,
              defaultValue: 0,
            },
          },
          {
            sequelize,
            tableName: 'download_histories',
          }
        );
        
        User.hasMany(DownloadHistory, { foreignKey: 'userId', as: 'downloadHistories' });
        Product.hasMany(DownloadHistory, { foreignKey: 'productId', as: 'downloadHistories' });
        DownloadHistory.belongsTo(User, { foreignKey: 'userId', as: 'user' });
        DownloadHistory.belongsTo(Product, { foreignKey: 'productId', as: 'product' });
        
        export default DownloadHistory;
        
        ```
        
2. **データベースへのモデル同期**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import DownloadHistory from './models/DownloadHistory';
        
        // ... 既存のコード
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        // 残りのコードは既存のまま
        
        ```
        

### **12.2. ダウンロードルートの作成**

1. **`download.ts`の作成**
    
    ```tsx
    // src/routes/download.ts
    import { Router, Request, Response } from 'express';
    import { authenticateToken } from '../middleware/authMiddleware';
    import Product from '../models/Product';
    import DownloadHistory from '../models/DownloadHistory';
    import AWS from 'aws-sdk';
    
    const router = Router();
    
    // AWS S3設定
    const s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_S3_REGION,
    });
    
    // ダウンロードエンドポイント
    router.get('/:productId', authenticateToken, async (req: Request, res: Response) => {
      const { productId } = req.params;
      const userId = req.user.id;
    
      try {
        const product = await Product.findByPk(productId);
        if (!product) {
          return res.status(404).json({ message: 'Product not found.' });
        }
    
        // ダウンロード制限の確認（例: 同時ダウンロード数、期限など）
        // ここでは簡略化のためスキップ
    
        // S3からファイルを取得
        const params = {
          Bucket: process.env.AWS_S3_BUCKET_NAME!,
          Key: product.fileUrl.split('/').pop()!, // ファイル名を取得
        };
    
        const fileStream = s3.getObject(params).createReadStream();
        res.setHeader('Content-Disposition', `attachment; filename="${product.title}.${product.fileType}"`);
        res.setHeader('Content-Type', product.fileType === 'pdf' ? 'application/pdf' : product.fileType === 'mp4' ? 'video/mp4' : 'audio/mpeg');
    
        // ダウンロード履歴の記録
        const downloadHistory = await DownloadHistory.create({
          userId,
          productId: product.id,
          downloadDate: new Date(),
          duration: 0, // 初期値、フロントエンドから利用時間を更新する必要あり
        });
    
        fileStream.pipe(res);
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Download failed.' });
      }
    });
    
    export default router;
    
    ```
    
2. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import downloadRoutes from './routes/download';
        
        // ... 既存のコード
        
        app.use('/api/download', downloadRoutes);
        
        // 残りのコードは既存のまま
        
        ```
        

### **12.3. フロントエンドでのダウンロード機能の実装**

1. **商材詳細ページでのダウンロードボタンの追加**
    - **`ProductDetail.tsx`の編集**
        
        ```tsx
        // src/pages/ProductDetail.tsx
        import React, { useState, useEffect } from 'react';
        import axios from 'axios';
        import { useParams } from 'react-router-dom';
        import { Container, Typography, Button } from '@mui/material';
        
        const ProductDetail: React.FC = () => {
          const { productId } = useParams();
          const [product, setProduct] = useState<any>(null);
          const [message, setMessage] = useState('');
        
          useEffect(() => {
            const fetchProduct = async () => {
              try {
                const res = await axios.get(`/api/product/${productId}`);
                setProduct(res.data.product);
              } catch (error: any) {
                setMessage(error.response?.data?.message || 'Failed to fetch product.');
              }
            };
        
            fetchProduct();
          }, [productId]);
        
          const handleDownload = async () => {
            const token = localStorage.getItem('token');
            try {
              const res = await axios.get(`/api/download/${productId}`, {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
                responseType: 'blob',
              });
              const url = window.URL.createObjectURL(new Blob([res.data]));
              const link = document.createElement('a');
              link.href = url;
              link.setAttribute('download', `${product.title}.${product.fileType}`);
              document.body.appendChild(link);
              link.click();
              link.parentNode?.removeChild(link);
              setMessage('Download started.');
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Download failed.');
            }
          };
        
          if (!product) {
            return (
              <Container>
                <Typography variant="h6">{message || 'Loading...'}</Typography>
              </Container>
            );
          }
        
          return (
            <Container>
              <Typography variant="h4" gutterBottom>
                {product.title}
              </Typography>
              <Typography variant="body1" gutterBottom>
                {product.description}
              </Typography>
              <Typography variant="subtitle1" gutterBottom>
                Category: {product.category}
              </Typography>
              <Button variant="contained" color="primary" onClick={handleDownload}>
                Download
              </Button>
              {message && <Typography variant="body1" style={{ marginTop: '10px' }}>{message}</Typography>}
            </Container>
          );
        };
        
        export default ProductDetail;
        
        ```
        
2. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import ProductDetail from './pages/ProductDetail';
        
        // ... 既存のコード
        
        <Route path="/product/:productId" element={<ProductDetail />} />
        
        // ... 残りのコード
        
        ```
        
3. **ナビゲーションの更新**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        
        const App: React.FC = () => {
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        Register
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        Login
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        Profile
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        Subscription
                      </Button>
                      <Button color="inherit" component={Link} to="/ai">
                        AI Processing
                      </Button>
                      <Button color="inherit" component={Link} to="/products">
                        Products
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          Admin
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          Upload Product
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                Welcome to izumi
              </Typography>
            </div>
          );
        };
        
        export default App;
        
        ```
        
4. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement download functionality with backend and frontend integration"
    git push
    
    ```
    

---

## **ステップ13: 広告管理機能の実装**

### **13.1. 広告モデルの作成**

1. **広告モデルの作成**
    - **`Ad.ts`の作成**
        
        ```tsx
        // src/models/Ad.ts
        import { DataTypes, Model } from 'sequelize';
        import sequelize from '../config/database';
        
        class Ad extends Model {
          public id!: number;
          public adType!: string; // 'video', 'banner'
          public contentUrl!: string;
          public targetUrl!: string;
          public active!: boolean;
          public readonly createdAt!: Date;
          public readonly updatedAt!: Date;
        }
        
        Ad.init(
          {
            id: {
              type: DataTypes.INTEGER,
              autoIncrement: true,
              primaryKey: true,
            },
            adType: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            contentUrl: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            targetUrl: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            active: {
              type: DataTypes.BOOLEAN,
              allowNull: false,
              defaultValue: true,
            },
          },
          {
            sequelize,
            tableName: 'ads',
          }
        );
        
        export default Ad;
        
        ```
        
2. **データベースへのモデル同期**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import Ad from './models/Ad';
        
        // ... 既存のコード
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        // 残りのコードは既存のまま
        
        ```
        

### **13.2. 広告ルートの作成**

1. **`ad.ts`の作成**
    
    ```tsx
    // src/routes/ad.ts
    import { Router, Request, Response } from 'express';
    import { authenticateToken, authorizeRoles } from '../middleware/authMiddleware';
    import Ad from '../models/Ad';
    
    const router = Router();
    
    // 広告の作成（管理者専用）
    router.post('/', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
      const { adType, contentUrl, targetUrl } = req.body;
    
      // 入力のバリデーション
      if (!['video', 'banner'].includes(adType)) {
        return res.status(400).json({ message: 'Invalid ad type.' });
      }
    
      try {
        const ad = await Ad.create({
          adType,
          contentUrl,
          targetUrl,
          active: true,
        });
    
        res.status(201).json({ message: 'Ad created successfully.', ad });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Ad creation failed.' });
      }
    });
    
    // 広告の取得（全ユーザー）
    router.get('/', async (req: Request, res: Response) => {
      try {
        const ads = await Ad.findAll({ where: { active: true } });
        res.status(200).json({ ads });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Failed to fetch ads.' });
      }
    });
    
    // 広告の更新（管理者専用）
    router.put('/:id', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
      const { id } = req.params;
      const { adType, contentUrl, targetUrl, active } = req.body;
    
      try {
        const ad = await Ad.findByPk(id);
        if (!ad) {
          return res.status(404).json({ message: 'Ad not found.' });
        }
    
        if (adType) {
          if (!['video', 'banner'].includes(adType)) {
            return res.status(400).json({ message: 'Invalid ad type.' });
          }
          ad.adType = adType;
        }
        if (contentUrl) ad.contentUrl = contentUrl;
        if (targetUrl) ad.targetUrl = targetUrl;
        if (typeof active === 'boolean') ad.active = active;
    
        await ad.save();
    
        res.status(200).json({ message: 'Ad updated successfully.', ad });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Ad update failed.' });
      }
    });
    
    // 広告の削除（管理者専用）
    router.delete('/:id', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
      const { id } = req.params;
    
      try {
        const ad = await Ad.findByPk(id);
        if (!ad) {
          return res.status(404).json({ message: 'Ad not found.' });
        }
    
        await ad.destroy();
    
        res.status(200).json({ message: 'Ad deleted successfully.' });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Ad deletion failed.' });
      }
    });
    
    export default router;
    
    ```
    
2. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import adRoutes from './routes/ad';
        
        // ... 既存のコード
        
        app.use('/api/ad', adRoutes);
        
        // 残りのコードは既存のまま
        
        ```
        

### **13.3. フロントエンドでの広告表示機能の実装**

1. **広告表示コンポーネントの作成**
    - **`AdBanner.tsx`の作成**
        
        ```tsx
        // src/components/AdBanner.tsx
        import React, { useEffect, useState } from 'react';
        import axios from 'axios';
        import { Card, CardMedia, CardContent, Typography } from '@mui/material';
        
        const AdBanner: React.FC = () => {
          const [ads, setAds] = useState<any[]>([]);
        
          useEffect(() => {
            const fetchAds = async () => {
              try {
                const res = await axios.get('/api/ad/');
                setAds(res.data.ads);
              } catch (error) {
                console.error('Failed to fetch ads:', error);
              }
            };
        
            fetchAds();
          }, []);
        
          return (
            <div style={{ marginTop: '20px' }}>
              {ads.map((ad) => (
                <Card key={ad.id} style={{ marginBottom: '20px' }}>
                  {ad.adType === 'video' ? (
                    <CardMedia component="video" src={ad.contentUrl} controls />
                  ) : (
                    <CardMedia component="img" height="140" image={ad.contentUrl} alt="Ad Banner" />
                  )}
                  <CardContent>
                    <Typography variant="body2" color="textSecondary" component="a" href={ad.targetUrl} target="_blank">
                      {ad.targetUrl}
                    </Typography>
                  </CardContent>
                </Card>
              ))}
            </div>
          );
        };
        
        export default AdBanner;
        
        ```
        
2. **アプリ全体での広告表示**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        import AdBanner from './components/AdBanner';
        
        const App: React.FC = () => {
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        Register
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        Login
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        Profile
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        Subscription
                      </Button>
                      <Button color="inherit" component={Link} to="/ai">
                        AI Processing
                      </Button>
                      <Button color="inherit" component={Link} to="/products">
                        Products
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          Admin
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          Upload Product
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                Welcome to izumi
              </Typography>
              <AdBanner />
            </div>
          );
        };
        
        export default App;
        
        ```
        
3. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement advertisement management and display features"
    git push
    
    ```
    

---

## **ステップ14: セキュリティ強化の実装**

### **14.1. データ保護の強化**

1. **パスワードのハッシュ化**
    - 既に`bcrypt`を使用してパスワードをハッシュ化していますが、追加で以下の設定を確認します。
2. **環境変数の利用**
    - **JWTシークレットキーの設定**
        - **`.env`ファイルに追加**
            
            ```
            JWT_SECRET=your_secure_jwt_secret
            
            ```
            
    - **`auth.ts`および他の認証関連ファイルの修正**
        
        ```tsx
        // src/routes/auth.ts
        // JWTの生成部分を修正
        const token = jwt.sign(
          { id: user.id, email: user.email, role: user.role },
          process.env.JWT_SECRET!,
          { expiresIn: '1h' }
        );
        
        ```
        

### **14.2. HTTPSの導入**

1. **SSL証明書の取得**
    - **Let's Encrypt**などの無料のSSL証明書を利用します。
2. **ExpressサーバーでのHTTPS設定**
    - **`server.ts`の作成**
        
        ```tsx
        // src/server.ts
        import https from 'https';
        import fs from 'fs';
        import app from './index'; // 既存のExpressアプリ
        
        const PORT = process.env.PORT || 5000;
        
        const httpsOptions = {
          key: fs.readFileSync('path/to/your/private.key'),
          cert: fs.readFileSync('path/to/your/certificate.crt'),
        };
        
        https.createServer(httpsOptions, app).listen(PORT, () => {
          console.log(`Secure server is running on port ${PORT}`);
        });
        
        ```
        
    - **`package.json`の修正**
        
        ```json
        "scripts": {
          "start": "node dist/server.js",
          "dev": "nodemon src/server.ts"
        }
        
        ```
        
3. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Enhance security with HTTPS and environment variables for secrets"
    git push
    
    ```
    

### **14.3. その他のセキュリティ対策**

1. **入力バリデーションの強化**
    - **`express-validator`の導入**
        
        ```bash
        npm install express-validator
        npm install --save-dev @types/express-validator
        
        ```
        
    - **`auth.ts`でのバリデーション追加**
        
        ```tsx
        // src/routes/auth.ts
        import { body, validationResult } from 'express-validator';
        
        // ユーザー登録ルートの修正
        router.post(
          '/register',
          [
            body('email').isEmail().withMessage('Invalid email address.'),
            body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters.'),
            body('name').notEmpty().withMessage('Name is required.'),
          ],
          async (req: Request, res: Response) => {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
              return res.status(400).json({ errors: errors.array() });
            }
        
            // 既存の登録ロジック
          }
        );
        
        ```
        
2. **セキュリティヘッダーの設定**
    - **`helmet`の導入**
        
        ```bash
        npm install helmet
        npm install --save-dev @types/helmet
        
        ```
        
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import helmet from 'helmet';
        
        app.use(helmet());
        
        ```
        
3. **クロスサイトスクリプティング（XSS）対策**
    - **フロントエンドでのエスケープ処理**
        - ReactはデフォルトでXSS対策が施されていますが、ユーザー入力を表示する際には注意が必要です。
4. **GitHubリポジトリでのシークレット管理**
    - **GitHub Secretsの利用**
        - GitHub Actionsで使用するシークレット（AWSキー、JWTシークレットなど）はGitHubのリポジトリ設定から管理します。
5. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Enhance security with HTTPS, environment variables, input validation, and security headers"
    git push
    
    ```
    

---

## **ステップ15: データ分析機能の実装**

### **15.1. データ分析モデルの作成**

1. **ユーザーログモデルの作成**
    - **`UserLog.ts`の作成**
        
        ```tsx
        // src/models/UserLog.ts
        import { DataTypes, Model } from 'sequelize';
        import sequelize from '../config/database';
        import User from './User';
        
        class UserLog extends Model {
          public id!: number;
          public userId!: number;
          public action!: string; // 'login', 'logout', 'view_product', etc.
          public timestamp!: Date;
          public readonly createdAt!: Date;
          public readonly updatedAt!: Date;
        }
        
        UserLog.init(
          {
            id: {
              type: DataTypes.INTEGER,
              autoIncrement: true,
              primaryKey: true,
            },
            userId: {
              type: DataTypes.INTEGER,
              allowNull: false,
              references: {
                model: User,
                key: 'id',
              },
            },
            action: {
              type: DataTypes.STRING,
              allowNull: false,
            },
            timestamp: {
              type: DataTypes.DATE,
              allowNull: false,
              defaultValue: DataTypes.NOW,
            },
          },
          {
            sequelize,
            tableName: 'user_logs',
          }
        );
        
        User.hasMany(UserLog, { foreignKey: 'userId', as: 'logs' });
        UserLog.belongsTo(User, { foreignKey: 'userId', as: 'user' });
        
        export default UserLog;
        
        ```
        
2. **データベースへのモデル同期**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import UserLog from './models/UserLog';
        
        // ... 既存のコード
        
        sequelize.authenticate()
          .then(() => {
            console.log('Database connected...');
            return sequelize.sync();
          })
          .then(() => {
            console.log('Models synchronized.');
          })
          .catch((err) => {
            console.error('Unable to connect to the database:', err);
          });
        
        // 残りのコードは既存のまま
        
        ```
        

### **15.2. データ分析APIの作成**

1. **`analytics.ts`の作成**
    
    ```tsx
    // src/routes/analytics.ts
    import { Router, Request, Response } from 'express';
    import { authenticateToken, authorizeRoles } from '../middleware/authMiddleware';
    import UserLog from '../models/UserLog';
    import Subscription from '../models/Subscription';
    import Product from '../models/Product';
    import DownloadHistory from '../models/DownloadHistory';
    
    const router = Router();
    
    // ユーザー行動ログの取得（管理者専用）
    router.get('/user-logs', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
      try {
        const logs = await UserLog.findAll({
          include: [{ model: UserLog.associations.user, as: 'user', attributes: ['id', 'email', 'name'] }],
          order: [['timestamp', 'DESC']],
        });
        res.status(200).json({ logs });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Failed to fetch user logs.' });
      }
    });
    
    // 収益レポートの取得（管理者専用）
    router.get('/revenue-report', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
      try {
        // サブスクリプション収益
        const subscriptions = await Subscription.findAll();
        const subscriptionRevenue = subscriptions.reduce((acc, sub) => {
          let price = 0;
          switch (sub.plan) {
            case 'Basic':
              price = 890;
              break;
            case 'Pro':
              price = 1280;
              break;
            case 'Premium':
              price = 1980;
              break;
            default:
              price = 0;
          }
          return acc + price;
        }, 0);
    
        // トランザクションフィー収益
        const products = await Product.findAll();
        const transactionFees = products.reduce((acc, product) => {
          const feePercentage = 0.1; // 10%
          return acc + product.fileSize * feePercentage;
        }, 0);
    
        res.status(200).json({
          subscriptionRevenue,
          transactionFees,
          totalRevenue: subscriptionRevenue + transactionFees,
        });
      } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Failed to fetch revenue report.' });
      }
    });
    
    export default router;
    
    ```
    
2. **ルートの統合**
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import analyticsRoutes from './routes/analytics';
        
        // ... 既存のコード
        
        app.use('/api/analytics', analyticsRoutes);
        
        // 残りのコードは既存のまま
        
        ```
        

### **15.3. フロントエンドでのデータ分析ページの作成**

1. **分析レポートページの作成**
    - **`RevenueReport.tsx`の作成**
        
        ```tsx
        // src/pages/RevenueReport.tsx
        import React, { useState, useEffect } from 'react';
        import axios from 'axios';
        import { Container, Typography } from '@mui/material';
        
        const RevenueReport: React.FC = () => {
          const [report, setReport] = useState<any>(null);
          const [message, setMessage] = useState('');
        
          useEffect(() => {
            const fetchReport = async () => {
              const token = localStorage.getItem('token');
              try {
                const res = await axios.get('/api/analytics/revenue-report', {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                });
                setReport(res.data);
              } catch (error: any) {
                setMessage(error.response?.data?.message || 'Failed to fetch revenue report.');
              }
            };
        
            fetchReport();
          }, []);
        
          if (!report) {
            return (
              <Container>
                <Typography variant="h6">{message || 'Loading...'}</Typography>
              </Container>
            );
          }
        
          return (
            <Container>
              <Typography variant="h4" gutterBottom>
                Revenue Report
              </Typography>
              <Typography variant="h6">Subscription Revenue: ¥{report.subscriptionRevenue}</Typography>
              <Typography variant="h6">Transaction Fees: ¥{report.transactionFees}</Typography>
              <Typography variant="h5" style={{ marginTop: '20px' }}>
                Total Revenue: ¥{report.totalRevenue}
              </Typography>
            </Container>
          );
        };
        
        export default RevenueReport;
        
        ```
        
2. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import RevenueReport from './pages/RevenueReport';
        
        // ... 既存のコード
        
        <Route path="/revenue-report" element={<RevenueReport />} />
        
        // ... 残りのコード
        
        ```
        
3. **管理者専用ページへのアクセス制御**
    - **`Admin.tsx`の編集**
        
        ```tsx
        // src/pages/Admin.tsx
        import React, { useState, useEffect } from 'react';
        import axios from 'axios';
        import { Container, Typography, Table, TableBody, TableCell, TableHead, TableRow, Button } from '@mui/material';
        import { Link } from 'react-router-dom';
        
        const Admin: React.FC = () => {
          const [users, setUsers] = useState([]);
          const [message, setMessage] = useState('');
        
          useEffect(() => {
            const fetchUsers = async () => {
              const token = localStorage.getItem('token');
              try {
                const res = await axios.get('/api/admin/users', {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                });
                setUsers(res.data);
              } catch (error: any) {
                setMessage(error.response?.data?.message || 'Failed to fetch users.');
              }
            };
        
            fetchUsers();
          }, []);
        
          const handleBan = async (id: number) => {
            const token = localStorage.getItem('token');
            try {
              const res = await axios.post(`/api/admin/ban/${id}`, {}, {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
              });
              setMessage(res.data.message);
              // 更新後のユーザーリストを再取得
              const updatedUsers = users.map((user: any) =>
                user.id === id ? { ...user, banned: true } : user
              );
              setUsers(updatedUsers);
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Failed to ban user.');
            }
          };
        
          return (
            <Container>
              <Typography variant="h4" gutterBottom>
                Admin Panel
              </Typography>
              <Button component={Link} to="/revenue-report" variant="contained" color="primary" style={{ marginBottom: '20px' }}>
                View Revenue Report
              </Button>
              {message && <Typography variant="body1">{message}</Typography>}
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>ID</TableCell>
                    <TableCell>Email</TableCell>
                    <TableCell>Name</TableCell>
                    <TableCell>Role</TableCell>
                    <TableCell>Actions</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {users.map((user: any) => (
                    <TableRow key={user.id}>
                      <TableCell>{user.id}</TableCell>
                      <TableCell>{user.email}</TableCell>
                      <TableCell>{user.name}</TableCell>
                      <TableCell>{user.role}</TableCell>
                      <TableCell>
                        <Button variant="contained" color="secondary" onClick={() => handleBan(user.id)}>
                          BAN
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Container>
          );
        };
        
        export default Admin;
        
        ```
        
4. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement data analytics features including revenue reports and user logs"
    git push
    
    ```
    

---

## **ステップ16: 国際化・ローカライゼーションの実装**

### **16.1. フロントエンドでの国際化設定**

1. **必要なパッケージのインストール**
    
    ```bash
    cd client
    npm install react-i18next i18next
    npm install --save-dev @types/react-i18next
    
    ```
    
2. **i18n設定ファイルの作成**
    - **`src/i18n.ts`の作成**
        
        ```tsx
        // src/i18n.ts
        import i18n from 'i18next';
        import { initReactI18next } from 'react-i18next';
        
        import translationEN from './locales/en/translation.json';
        import translationJP from './locales/jp/translation.json';
        
        const resources = {
          en: {
            translation: translationEN,
          },
          jp: {
            translation: translationJP,
          },
        };
        
        i18n
          .use(initReactI18next)
          .init({
            resources,
            lng: 'jp', // 初期言語
            keySeparator: false,
            interpolation: {
              escapeValue: false,
            },
          });
        
        export default i18n;
        
        ```
        
3. **翻訳ファイルの作成**
    - **`src/locales/en/translation.json`の作成**
        
        ```json
        {
          "Welcome": "Welcome to izumi",
          "Register": "Register",
          "Login": "Login",
          "Profile": "Profile",
          "Subscription": "Subscription",
          "AI Processing": "AI Processing",
          "Products": "Products",
          "Admin": "Admin",
          "Upload Product": "Upload Product",
          "Revenue Report": "Revenue Report",
          "User Logs": "User Logs",
          "Ad Banner": "Ad Banner",
          "Download": "Download",
          "Download Started": "Download started.",
          "Download Failed": "Download failed.",
          "Subscribe": "Subscribe",
          "Change Plan": "Change Plan",
          "Cancel Subscription": "Cancel Subscription",
          "Subscription Success": "Subscribed successfully.",
          "Subscription Failed": "Subscription failed.",
          "Plan Change Success": "Subscription plan updated successfully.",
          "Plan Change Failed": "Plan change failed.",
          "Cancellation Success": "Subscription canceled successfully.",
          "Cancellation Failed": "Cancellation failed."
        }
        
        ```
        
    - **`src/locales/jp/translation.json`の作成**
        
        ```json
        {
          "Welcome": "izumiへようこそ",
          "Register": "登録",
          "Login": "ログイン",
          "Profile": "プロフィール",
          "Subscription": "サブスクリプション",
          "AI Processing": "AI処理",
          "Products": "商材",
          "Admin": "管理者",
          "Upload Product": "商材をアップロード",
          "Revenue Report": "収益レポート",
          "User Logs": "ユーザーログ",
          "Ad Banner": "広告バナー",
          "Download": "ダウンロード",
          "Download Started": "ダウンロードを開始しました。",
          "Download Failed": "ダウンロードに失敗しました。",
          "Subscribe": "サブスクライブ",
          "Change Plan": "プランを変更",
          "Cancel Subscription": "サブスクリプションを解約",
          "Subscription Success": "サブスクリプションに成功しました。",
          "Subscription Failed": "サブスクリプションに失敗しました。",
          "Plan Change Success": "サブスクリプションプランを更新しました。",
          "Plan Change Failed": "プランの変更に失敗しました。",
          "Cancellation Success": "サブスクリプションを解約しました。",
          "Cancellation Failed": "解約に失敗しました。"
        }
        
        ```
        
4. **i18nの初期化**
    - **`src/main.tsx`の修正**
        
        ```tsx
        // src/main.tsx
        import React from 'react';
        import ReactDOM from 'react-dom';
        import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
        import App from './App';
        import Register from './pages/Register';
        import Login from './pages/Login';
        import Profile from './pages/Profile';
        import Admin from './pages/Admin';
        import UploadProduct from './pages/UploadProduct';
        import Subscription from './pages/Subscription';
        import AIProcessing from './pages/AIProcessing';
        import RevenueReport from './pages/RevenueReport';
        import ProductDetail from './pages/ProductDetail';
        import './i18n';
        
        ReactDOM.render(
          <React.StrictMode>
            <Router>
              <Routes>
                <Route path="/" element={<App />} />
                <Route path="/register" element={<Register />} />
                <Route path="/login" element={<Login />} />
                <Route path="/profile" element={<Profile />} />
                <Route path="/subscription" element={<Subscription />} />
                <Route path="/ai" element={<AIProcessing />} />
                <Route path="/revenue-report" element={<RevenueReport />} />
                <Route path="/product/:productId" element={<ProductDetail />} />
                <Route path="/admin" element={<Admin />} />
                <Route path="/upload" element={<UploadProduct />} />
              </Routes>
            </Router>
          </React.StrictMode>,
          document.getElementById('root')
        );
        
        ```
        
5. **言語切り替えコンポーネントの作成**
    - **`LanguageSwitcher.tsx`の作成**
        
        ```tsx
        // src/components/LanguageSwitcher.tsx
        import React from 'react';
        import { useTranslation } from 'react-i18next';
        import { ButtonGroup, Button } from '@mui/material';
        
        const LanguageSwitcher: React.FC = () => {
          const { i18n } = useTranslation();
        
          const changeLanguage = (lng: string) => {
            i18n.changeLanguage(lng);
          };
        
          return (
            <ButtonGroup variant="text" color="inherit">
              <Button onClick={() => changeLanguage('jp')}>JP</Button>
              <Button onClick={() => changeLanguage('en')}>EN</Button>
            </ButtonGroup>
          );
        };
        
        export default LanguageSwitcher;
        
        ```
        
6. **ナビゲーションに言語切り替えを追加**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        import AdBanner from './components/AdBanner';
        import LanguageSwitcher from './components/LanguageSwitcher';
        import { useTranslation } from 'react-i18next';
        
        const App: React.FC = () => {
          const { t } = useTranslation();
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  <LanguageSwitcher />
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        {t('Register')}
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        {t('Login')}
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        {t('Profile')}
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        {t('Subscription')}
                      </Button>
                      <Button color="inherit" component={Link} to="/ai">
                        {t('AI Processing')}
                      </Button>
                      <Button color="inherit" component={Link} to="/products">
                        {t('Products')}
                      </Button>
                      <Button color="inherit" component={Link} to="/revenue-report">
                        {t('Revenue Report')}
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          {t('Admin')}
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          {t('Upload Product')}
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                {t('Welcome')}
              </Typography>
              <AdBanner />
            </div>
          );
        };
        
        export default App;
        
        ```
        
7. **翻訳の適用**
    - 各ページやコンポーネントで`useTranslation`フックを使用してテキストを翻訳します。
    - **例: `Register.tsx`の修正**
        
        ```tsx
        // src/pages/Register.tsx
        import React, { useState } from 'react';
        import axios from 'axios';
        import { TextField, Button, Container, Typography } from '@mui/material';
        import { useTranslation } from 'react-i18next';
        
        const Register: React.FC = () => {
          const { t } = useTranslation();
          const [email, setEmail] = useState('');
          const [password, setPassword] = useState('');
          const [name, setName] = useState('');
          const [message, setMessage] = useState('');
        
          const handleRegister = async (e: React.FormEvent) => {
            e.preventDefault();
            try {
              const res = await axios.post('/api/auth/register', { email, password, name });
              setMessage(t('Subscription Success'));
            } catch (error: any) {
              setMessage(error.response?.data?.message || t('Subscription Failed'));
            }
          };
        
          return (
            <Container maxWidth="sm">
              <Typography variant="h4" gutterBottom>
                {t('Register')}
              </Typography>
              <form onSubmit={handleRegister}>
                <TextField
                  label={t('Name')}
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  required
                />
                <TextField
                  label={t('Email')}
                  type="email"
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                />
                <TextField
                  label={t('Password')}
                  type="password"
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                />
                <Button type="submit" variant="contained" color="primary" fullWidth>
                  {t('Register')}
                </Button>
              </form>
              {message && <Typography variant="body1">{message}</Typography>}
            </Container>
          );
        };
        
        export default Register;
        
        ```
        
8. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement internationalization and localization with react-i18next"
    git push
    
    ```
    

---

## **ステップ17: アクセシビリティの強化**

### **17.1. フロントエンドでのアクセシビリティ改善**

1. **ARIA属性の追加**
    - 各コンポーネントに適切なARIA属性を追加して、スクリーンリーダー対応を強化します。
    - **例: `AdBanner.tsx`の修正**
        
        ```tsx
        // src/components/AdBanner.tsx
        // ... 既存のインポート
        
        const AdBanner: React.FC = () => {
          const [ads, setAds] = useState<any[]>([]);
        
          useEffect(() => {
            const fetchAds = async () => {
              try {
                const res = await axios.get('/api/ad/');
                setAds(res.data.ads);
              } catch (error) {
                console.error('Failed to fetch ads:', error);
              }
            };
        
            fetchAds();
          }, []);
        
          return (
            <div style={{ marginTop: '20px' }}>
              {ads.map((ad) => (
                <Card key={ad.id} style={{ marginBottom: '20px' }} role="region" aria-label="Advertisement">
                  {ad.adType === 'video' ? (
                    <CardMedia component="video" src={ad.contentUrl} controls aria-label="Advertisement Video" />
                  ) : (
                    <CardMedia component="img" height="140" image={ad.contentUrl} alt="Ad Banner" />
                  )}
                  <CardContent>
                    <Typography variant="body2" color="textSecondary" component="a" href={ad.targetUrl} target="_blank">
                      {ad.targetUrl}
                    </Typography>
                  </CardContent>
                </Card>
              ))}
            </div>
          );
        };
        
        export default AdBanner;
        
        ```
        
2. **キーボードナビゲーションの確認**
    - すべてのインタラクティブな要素（ボタン、リンク、フォーム）はキーボード操作でアクセス可能であることを確認します。
3. **コントラスト比の最適化**
    - テキストと背景のコントラスト比を十分に高く設定し、視認性を向上させます。
    - **例: テキストカラーの修正**
        
        ```tsx
        // src/App.tsx
        <Typography variant="h3" align="center" style={{ marginTop: '50px', color: '#333333' }}>
          {t('Welcome')}
        </Typography>
        
        ```
        
4. **スクリーンリーダー用のラベル追加**
    - フォーム要素や画像に対して、スクリーンリーダーが内容を正しく理解できるようにラベルを追加します。
    - **例: ファイルアップロードボタンの修正**
        
        ```tsx
        // src/pages/AIProcessing.tsx
        <label htmlFor="audio-upload">
          <Button variant="contained" component="span" fullWidth aria-label="Upload Audio File">
            Upload Audio File
          </Button>
        </label>
        
        ```
        
5. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Enhance accessibility with ARIA attributes, keyboard navigation, and contrast optimization"
    git push
    
    ```
    

---

## **ステップ18: 法的・コンプライアンス要件の実装**

### **18.1. 利用規約とプライバシーポリシーの作成と統合**

1. **利用規約ページの作成**
    - **`TermsOfService.tsx`の作成**
        
        ```tsx
        // src/pages/TermsOfService.tsx
        import React from 'react';
        import { Container, Typography } from '@mui/material';
        
        const TermsOfService: React.FC = () => {
          return (
            <Container maxWidth="md">
              <Typography variant="h4" gutterBottom>
                利用規約
              </Typography>
              <Typography variant="body1" paragraph>
                ここに利用規約の内容を記載します。
              </Typography>
              {/* 追加のセクション */}
            </Container>
          );
        };
        
        export default TermsOfService;
        
        ```
        
2. **プライバシーポリシーページの作成**
    - **`PrivacyPolicy.tsx`の作成**
        
        ```tsx
        // src/pages/PrivacyPolicy.tsx
        import React from 'react';
        import { Container, Typography } from '@mui/material';
        
        const PrivacyPolicy: React.FC = () => {
          return (
            <Container maxWidth="md">
              <Typography variant="h4" gutterBottom>
                プライバシーポリシー
              </Typography>
              <Typography variant="body1" paragraph>
                ここにプライバシーポリシーの内容を記載します。
              </Typography>
              {/* 追加のセクション */}
            </Container>
          );
        };
        
        export default PrivacyPolicy;
        
        ```
        
3. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import TermsOfService from './pages/TermsOfService';
        import PrivacyPolicy from './pages/PrivacyPolicy';
        
        // ... 既存のコード
        
        <Route path="/terms" element={<TermsOfService />} />
        <Route path="/privacy" element={<PrivacyPolicy />} />
        
        // ... 残りのコード
        
        ```
        
4. **フッターにリンクの追加**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        import AdBanner from './components/AdBanner';
        import LanguageSwitcher from './components/LanguageSwitcher';
        import { useTranslation } from 'react-i18next';
        
        const App: React.FC = () => {
          const { t } = useTranslation();
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  <LanguageSwitcher />
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        {t('Register')}
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        {t('Login')}
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        {t('Profile')}
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        {t('Subscription')}
                      </Button>
                      <Button color="inherit" component={Link} to="/ai">
                        {t('AI Processing')}
                      </Button>
                      <Button color="inherit" component={Link} to="/products">
                        {t('Products')}
                      </Button>
                      <Button color="inherit" component={Link} to="/revenue-report">
                        {t('Revenue Report')}
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          {t('Admin')}
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          {t('Upload Product')}
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                {t('Welcome')}
              </Typography>
              <AdBanner />
              <footer style={{ marginTop: '50px', padding: '20px', backgroundColor: '#f5f5f5', textAlign: 'center' }}>
                <Typography variant="body2">
                  <Link to="/terms">利用規約</Link> | <Link to="/privacy">プライバシーポリシー</Link>
                </Typography>
              </footer>
            </div>
          );
        };
        
        export default App;
        
        ```
        
5. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement Terms of Service and Privacy Policy pages with routing and footer links"
    git push
    
    ```
    

---

## **ステップ19: デプロイと運用**

### **19.1. 本番環境へのデプロイ準備**

1. **ビルドの作成**
    - **バックエンドのビルド**
        
        ```bash
        cd server
        npm run build
        
        ```
        
    - **フロントエンドのビルド**
        
        ```bash
        cd ../client
        npm run build
        
        ```
        
2. **Dockerイメージの再ビルド**
    - **サーバーイメージのビルド**
        
        ```bash
        cd ../server
        docker build -t izumi-server .
        
        ```
        
    - **クライアントイメージのビルド**
        
        ```bash
        cd ../client
        docker build -t izumi-client .
        
        ```
        
3. **AWS ECSでのデプロイ**
    - **タスク定義の更新**
        - 最新のDockerイメージを使用するようにタスク定義を更新します。
    - **サービスの更新**
        - 新しいタスク定義を基にサービスを更新し、デプロイします。
4. **ロードバランサーの設定**
    - **ALBの設定**
        - HTTPおよびHTTPSリスナーを設定し、トラフィックを適切なサービスにルーティングします。

### **19.2. モニタリングとロギングの設定**

1. **モニタリングツールの導入**
    - **Datadogの設定**
        - Datadogエージェントをインストールし、サーバーおよびクライアントのパフォーマンスを監視します。
2. **ログ管理の設定**
    - **ELK Stackの設定**
        - Elasticsearch、Logstash、Kibanaを使用してログを収集・可視化します。

### **19.3. 定期的なバックアップの設定**

1. **データベースのバックアップ**
    - **PostgreSQLの定期バックアップスクリプトを作成**
        
        ```bash
        #!/bin/bash
        TIMESTAMP=$(date +"%F")
        pg_dump -U izumi_user -h localhost izumi_db > /backups/izumi_db_$TIMESTAMP.sql
        
        ```
        
    - **cronジョブの設定**
        
        ```bash
        crontab -e
        
        ```
        
        ```
        0 2 * * * /path/to/backup_script.sh
        
        ```
        
2. **ファイルストレージのバックアップ**
    - **AWS S3のバケットバージョニングとライフサイクルポリシーの設定**
        - バケットのバージョニングを有効にし、古いオブジェクトを自動的にアーカイブまたは削除するライフサイクルポリシーを設定します。

### **19.4. Gitへのコミット**

```bash
git add .
git commit -m "Prepare for production deployment with Docker, AWS ECS, monitoring, and backup strategies"
git push

```

---

## **ステップ20: 継続的な改善とアップデート**

### **20.1. ユーザーフィードバックの収集と分析**

1. **フィードバックフォームの実装**
    - **`Feedback.tsx`の作成**
        
        ```tsx
        // src/pages/Feedback.tsx
        import React, { useState } from 'react';
        import axios from 'axios';
        import { Container, Typography, TextField, Button } from '@mui/material';
        import { useTranslation } from 'react-i18next';
        
        const Feedback: React.FC = () => {
          const { t } = useTranslation();
          const [feedback, setFeedback] = useState('');
          const [message, setMessage] = useState('');
        
          const handleSubmit = async (e: React.FormEvent) => {
            e.preventDefault();
            const token = localStorage.getItem('token');
            try {
              await axios.post(
                '/api/feedback',
                { feedback },
                {
                  headers: {
                    Authorization: `Bearer ${token}`,
                  },
                }
              );
              setMessage('Feedback submitted successfully.');
              setFeedback('');
            } catch (error: any) {
              setMessage(error.response?.data?.message || 'Failed to submit feedback.');
            }
          };
        
          return (
            <Container maxWidth="sm">
              <Typography variant="h4" gutterBottom>
                {t('User Feedback')}
              </Typography>
              <form onSubmit={handleSubmit}>
                <TextField
                  label="Feedback"
                  variant="outlined"
                  fullWidth
                  margin="normal"
                  multiline
                  rows={4}
                  value={feedback}
                  onChange={(e) => setFeedback(e.target.value)}
                  required
                />
                <Button type="submit" variant="contained" color="primary" fullWidth>
                  Submit
                </Button>
              </form>
              {message && <Typography variant="body1" style={{ marginTop: '20px' }}>{message}</Typography>}
            </Container>
          );
        };
        
        export default Feedback;
        
        ```
        
2. **バックエンドでのフィードバックAPIの作成**
    - **`feedback.ts`の作成**
        
        ```tsx
        // src/routes/feedback.ts
        import { Router, Request, Response } from 'express';
        import { authenticateToken } from '../middleware/authMiddleware';
        import User from '../models/User';
        
        const router = Router();
        
        // フィードバックの投稿
        router.post('/', authenticateToken, async (req: Request, res: Response) => {
          const { feedback } = req.body;
          const userId = req.user.id;
        
          if (!feedback) {
            return res.status(400).json({ message: 'Feedback is required.' });
          }
        
          try {
            // フィードバックをデータベースに保存するモデルが未作成の場合、ここで保存処理を実装
            // 例: Feedbackモデルの作成と保存
        
            // ダミーレスポンス
            res.status(200).json({ message: 'Feedback submitted successfully.' });
          } catch (error) {
            console.error(error);
            res.status(500).json({ message: 'Failed to submit feedback.' });
          }
        });
        
        export default router;
        
        ```
        
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import feedbackRoutes from './routes/feedback';
        
        // ... 既存のコード
        
        app.use('/api/feedback', feedbackRoutes);
        
        // 残りのコードは既存のまま
        
        ```
        
3. **ルーティングの追加**
    - **`src/main.tsx`の編集**
        
        ```tsx
        // src/main.tsx
        import Feedback from './pages/Feedback';
        
        // ... 既存のコード
        
        <Route path="/feedback" element={<Feedback />} />
        
        // ... 残りのコード
        
        ```
        
4. **ナビゲーションの更新**
    - **`App.tsx`の修正**
        
        ```tsx
        // src/App.tsx
        import React from 'react';
        import { Link } from 'react-router-dom';
        import { AppBar, Toolbar, Typography, Button } from '@mui/material';
        import AdBanner from './components/AdBanner';
        import LanguageSwitcher from './components/LanguageSwitcher';
        import { useTranslation } from 'react-i18next';
        
        const App: React.FC = () => {
          const { t } = useTranslation();
          const token = localStorage.getItem('token');
          const [role, setRole] = React.useState<string | null>(null);
        
          React.useEffect(() => {
            if (token) {
              const decoded: any = JSON.parse(atob(token.split('.')[1]));
              setRole(decoded.role);
            }
          }, [token]);
        
          return (
            <div>
              <AppBar position="static">
                <Toolbar>
                  <Typography variant="h6" style={{ flexGrow: 1 }}>
                    izumi
                  </Typography>
                  <LanguageSwitcher />
                  {!token && (
                    <>
                      <Button color="inherit" component={Link} to="/register">
                        {t('Register')}
                      </Button>
                      <Button color="inherit" component={Link} to="/login">
                        {t('Login')}
                      </Button>
                    </>
                  )}
                  {token && (
                    <>
                      <Button color="inherit" component={Link} to="/profile">
                        {t('Profile')}
                      </Button>
                      <Button color="inherit" component={Link} to="/subscription">
                        {t('Subscription')}
                      </Button>
                      <Button color="inherit" component={Link} to="/ai">
                        {t('AI Processing')}
                      </Button>
                      <Button color="inherit" component={Link} to="/products">
                        {t('Products')}
                      </Button>
                      <Button color="inherit" component={Link} to="/revenue-report">
                        {t('Revenue Report')}
                      </Button>
                      <Button color="inherit" component={Link} to="/feedback">
                        {t('User Feedback')}
                      </Button>
                      {role === 'admin' && (
                        <Button color="inherit" component={Link} to="/admin">
                          {t('Admin')}
                        </Button>
                      )}
                      {role === 'provider' && (
                        <Button color="inherit" component={Link} to="/upload">
                          {t('Upload Product')}
                        </Button>
                      )}
                    </>
                  )}
                </Toolbar>
              </AppBar>
              <Typography variant="h3" align="center" style={{ marginTop: '50px' }}>
                {t('Welcome')}
              </Typography>
              <AdBanner />
              <footer style={{ marginTop: '50px', padding: '20px', backgroundColor: '#f5f5f5', textAlign: 'center' }}>
                <Typography variant="body2">
                  <Link to="/terms">利用規約</Link> | <Link to="/privacy">プライバシーポリシー</Link> | <Link to="/feedback">フィードバック</Link>
                </Typography>
              </footer>
            </div>
          );
        };
        
        export default App;
        
        ```
        
5. **Gitへのコミット**
    
    ```bash
    git add .
    git commit -m "Implement user feedback collection and integration with backend"
    git push
    
    ```
    

---

## **ステップ21: 継続的なモニタリングとメンテナンス**

### **21.1. パフォーマンスモニタリングの設定**

1. **Datadogエージェントの設定**
    - **サーバーにDatadogエージェントをインストール**
        - [Datadog公式ガイド](https://docs.datadoghq.com/agent/)に従ってエージェントをインストールします。
2. **カスタムメトリクスの送信**
    - **Expressアプリでのミドルウェア作成**
        
        ```tsx
        // src/middleware/performanceMonitor.ts
        import { Request, Response, NextFunction } from 'express';
        import dd from 'datadog-metrics';
        
        dd.init({ host: 'localhost', prefix: 'izumi.' });
        
        export const performanceMonitor = (req: Request, res: Response, next: NextFunction) => {
          const start = process.hrtime();
        
          res.on('finish', () => {
            const diff = process.hrtime(start);
            const duration = diff[0] * 1e3 + diff[1] * 1e-6; // ミリ秒
            dd.histogram('response_time', duration, ['method:' + req.method, 'route:' + req.path, 'status:' + res.statusCode]);
          });
        
          next();
        };
        
        ```
        
    - **`index.ts`の修正**
        
        ```tsx
        // src/index.ts
        import { performanceMonitor } from './middleware/performanceMonitor';
        
        app.use(performanceMonitor);
        
        // 残りのコードは既存のまま
        
        ```
        

### **21.2. セキュリティアップデートの適用**

1. **依存関係の更新**
    - 定期的に`npm outdated`を実行し、依存パッケージの更新を確認します。
2. **脆弱性スキャンの実施**
    - **`npm audit`の実行**
        
        ```bash
        cd server
        npm audit fix
        
        cd ../client
        npm audit fix
        
        ```
        
3. **GitHub Dependabotの有効化**
    - GitHubリポジトリの設定からDependabotを有効にし、依存関係の自動更新を設定します。

### **21.3. 定期的なコードレビューとリファクタリング**

1. **コードレビューの実施**
    - チームメンバー間でプルリクエストを作成し、コードレビューを行います。
2. **リファクタリングの計画**
    - 技術的負債を減らすために、定期的にコードのリファクタリングを行います。

### **21.4. Gitへのコミット**

```bash
git add .
git commit -m "Set up performance monitoring with Datadog and implement regular security updates"
git push

```

---

## **まとめ**

これまでのステップ1～21では、**izumi**アプリの基本的な機能から高度な機能までを段階的に実装し、セキュリティやアクセシビリティ、国際化といった重要な側面にも対応してきました。今後も以下の点に留意しながら、プロジェクトを進めていくことをお勧めします。

1. **ユーザーフィードバックの活用**
    - 定期的にユーザーからのフィードバックを収集し、改善に反映させる。
2. **継続的なテストと品質保証**
    - ユニットテスト、統合テスト、エンドツーエンドテストを継続的に実施し、品質を維持する。
3. **スケーラビリティの確保**
    - ユーザー数の増加やトラフィックの増大に対応できるよう、インフラを適宜拡張・最適化する。
4. **ドキュメントの整備**
    - 技術ドキュメント、APIドキュメント、ユーザーマニュアルを充実させ、新しい開発者やユーザーがスムーズに利用・開発できるようにする。
5. **法的要件の遵守**
    - プライバシー規制や著作権法など、関連する法的要件を常に確認し、遵守する。

---

これで**開発計画書2**のステップ10以降の作成は完了です。プロジェクトの進行に応じて、必要に応じて計画を調整・更新してください。何か質問や追加のサポートが必要な場合は、遠慮なくお知らせください。